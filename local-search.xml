<?xml version="1.0" encoding="utf-8"?>
<search>
  
  
  
  <entry>
    <title>操作系统 概论</title>
    <link href="/2022/06/20/os-overview/"/>
    <url>/2022/06/20/os-overview/</url>
    
    <content type="html"><![CDATA[<h1 id="计算机系统">计算机系统</h1><p>计算机系统通常包括计算机硬件（Hardware）、操作系统（OperatingSystem）和应用程序（Application）以及用户（User）几个部分；操作系统运行在计算机硬件上，而应用程序依赖于操作系统向上层提供的一系列服务和接口运行，最后，用户使用应用程序完成自己的工作；这些部分之间的关系如下所示。</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><code class="hljs None"> ┌──────────────┐   ┌───────────────┐                 ┌──────────────┐<br> │     USER1    │   │     USER2     │    ... ...      │     USERn    │<br> └───────┬──────┘   └───────┬───────┘                 └───────┬──────┘<br>         │                  │                                 │<br>         ▼                  ▼                                 ▼<br>┌─────────────────────────────────────────────────────────────────────┐<br>│                                                                     │<br>│                             APPLICATION                             │<br>│                                                                     │<br>│         ┌────────────────────────────────────────────────┐          │<br>│         │                                                │          │<br>└─────────┤                OPERATING SYSTEM                ├──────────┘<br>          │                                                │<br>          │        ┌───────────────────────────────┐       │<br>          └────────┤                               ├───────┘<br>                   │           HARDWARE            │<br>                   │                               │<br>                   └───────────────────────────────┘<br></code></pre></td></tr></table></figure><p>可以看到，从硬件向上到应用程序，它们的覆盖范围是逐层加大的。可以这样理解：操作系统通过各种方法扩展和增强了硬件的功能（例如虚拟内存机制的使用，在应用程序层面来看扩充了实际内存的大小；又例如分时多任务机制的使用，在用户层面来看有多个程序在同时运行，但实际的处理器数量并没有这么多）；而应用程序又利用操作系统提供的各种接口和服务进一步扩展和增强了计算机的功能（例如五花八门的应用程序让用户通过计算机完成各种任务，而不仅限于计算）。</p><h1 id="操作系统">操作系统</h1><p>计算机系统是一个具有层次结构的系统，<strong>操作系统是处于硬件和应用程序中间的软件，它向上为应用程序提供简洁易用的资源抽象，屏蔽复杂的底层逻辑；向下管理种类繁多的硬件资源</strong>。</p><h2 id="功能和目标">功能和目标</h2><h3 id="功能">功能</h3><ul><li>资源管理（包括处理器管理、存储管理、设备管理、文件管理等）</li><li>控制执行（例如进程调度、进程的并发控制等）</li><li>提供接口（例如作业管理提供了向计算机输入作业的接口）</li></ul><h3 id="目标">目标</h3><ul><li>方便用户使用</li><li>提升机器能力（例如：并发控制使得单核处理器计算机也能“同时”运行多个程序）</li><li>提高运行效率（例如：并发有效利用了处理器资源）</li><li>提供开放环境（例如：操作系统提供了一个可供应用程序运行的开放环境）</li></ul><h2 id="主要特征">主要特征</h2><h3 id="并发性">并发性</h3><ul><li>并发是指两个或两个以上事件在<strong>同一时间间隔内</strong>发生。并发提高了资源利用率（一心多用），但是增加了管理复杂度（例如为了保证程序之间不相互影响而对资源进行的保护，等等）</li><li>支持并发的操作系统称之为多任务系统</li></ul><div class="note note-info">            <p>并行是指两个或两个以上事件或活动在<strong>同一时刻</strong>发生，它是并发的特例。</p>          </div><h3 id="共享性">共享性</h3><ul><li>共享性是指系统中的资源可被多个并发执行的任务（作业）所使用</li><li>两类共享方式：<ul><li>互斥访问（适用于某一时刻只能被一个任务访问的资源，例如打印机、屏幕输出等）</li><li>同时访问（适用于某一时刻可以被多个任务访问的资源，例如读取文件内容、读取传感器数据等）</li></ul></li></ul><h3 id="异步性">异步性</h3><ul><li>主要表现<ul><li>任务执行的时间、推进速度等不定（例如，每个程序执行的时间可能是不相同的）</li><li>事件发生的不可预期，如各种中断的发生（例如，我现在按了一下键盘的某个键）</li></ul></li><li>对操作系统的要求<ul><li>能够处理随机发生的各种事件</li><li>在不同的事件序列中，确保任务的正确执行（例如，程序不能因为我插了个耳机就崩溃了）</li></ul></li></ul><h3 id="虚拟性">虚拟性</h3><ul><li>虚拟性是操作系统中的一种管理技术，是指将物理上的一个实体变成逻辑上的多个对应物，或将物理上的多个实体变成逻辑上的一个对应物的技术。</li><li>例如，虚拟内存（将逻辑上的一个个内存块映射到不同的内存或磁盘空间中）</li></ul><h2 id="操作系统运行机制概览">操作系统运行机制概览</h2><h3 id="从接通电源到操作系统">从接通电源到操作系统</h3><h4 id="step-1接通电源运行bios">Step 1：接通电源，运行BIOS</h4><p>接通电源后，CPU首先会执行一条跳转指令，这条指令将会使CPU跳转BIOS代码继续执行，BIOS在进行一系列初始化和自检工作（该过程被称为POST过程）后，执行自举过程，该过程将第一阶段引导程序的代码（是主引导记录的一部分）从磁盘指定位置（磁盘的首个扇区）调入到内存中，随后跳转到第一阶段引导程序继续执行。</p><div class="note note-info">            <p>BIOS的全称是Basic Input OutputSystem，它是硬件厂商在硬件上自带的一段启动的代码，作用是进行一些硬件检查，并且跳转到引导程序bootloader。</p>          </div><div class="note note-info">            <p>引导程序，英文为Bootloader，引导在英文中为“boot”，是bootstrap的缩写，源自于短语“Pulloneself up by one'sbootstraps”，即“靠自己振作起来”。引导程序的任务是将另一段程序代码加载到内存中。</p>          </div><div class="note note-info">            <p>主引导记录，英文为Master BootRecord，简称MBR，又称主引导扇区，记录着引导程序代码和硬盘本身的相关信息以及硬盘各个分区的大小及位置信息。</p>          </div><h4 id="step-2第一阶段引导程序加载第二阶段引导程序">Step2：第一阶段引导程序加载第二阶段引导程序</h4><p>第一阶段引导程序经由BIOS加载并开始执行，而第一阶段引导程序将会把第二阶段引导程序加载到内存中，然后跳转到第二阶段引导程序。这么做的原因是第一阶段引导程序的大小受到限制（因为它存储在主引导记录中，而主引导记录仅有一个扇区大小），无法完成复杂的功能。</p><h4 id="step-3第二阶段引导程序加载操作系统">Step3：第二阶段引导程序加载操作系统</h4><p>第二阶段引导程序不再拘于一个扇区大小，因此可以完成更复杂的功能，它将会把操作系统内核（Kernel）加载到内存中，最终把计算机的控制权交给操作系统内核。常见的第二阶段引导程序有LILO、GRUB等。</p><div class="note note-info">            <p>对于UEFI系统，由EFI应用程序（即EFI系统分区中的<code>.efi</code>文件）取代MBR和第二阶段引导程序，UEFI固件会加载引导程序的<code>.efi</code>文件，再由引导程序加载操作系统。</p>          </div><p>至此，操作系统被顺利加载到内存并接管了计算机。</p><h3 id="操作系统初始化">操作系统初始化</h3><p>在UNIX/类UNIX操作系统中，操作系统内核（Kernel）首先构造出第一个进程（这里称为init进程），init进程通过fork和exec操作创建若干个子进程来进行各项任务（比如用户登录、终端、桌面，等等）。</p><h3 id="操作系统基本形态">操作系统基本形态</h3><p>如下所示，操作系统的核心主要包括调度程序（这里指短程调度，即选择已被加载到内存中的进程投入运行）和中断处理程序（这里包括来自进程的系统调用和来自进程或外部设备的中断）。</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br></pre></td><td class="code"><pre><code class="hljs None">                    ┌────────────────────────────────────────────────────────────────────────┐<br>                    │                                                                        │<br>                    │  ┌────────────────────┐                 ┌─────┐  ┌─────┐  ┌─────┐      │<br>                    │  │                    │                 │     │  │     │  └─────┘      │<br>                    │  │                    │                 │     │  │     │  ┌─────┐      │<br>Service Call  ──────┼──┼──► Service Call    │                 │     │  │     │  ├─────┤      │<br>    from Process    │  │       Handler      │                 │     │  │     │  └─────┘      │<br>                    │  │                    │                 │     │  │     │  ┌─────┐      │<br>                    │  └────────────────────┘                 │     │  │     │  └─────┘      │<br>                    │                                         │     │  │     │  ┌─────┐      │<br>                    │                                         │     │  │     │  ├─────┤      │<br>                    │                                         └─────┘  └─────┘  └─────┘      │<br>                    │                                      Long-Term  Short-Term  I/O        │<br>                    │                                          Queue       Queue   Queues    │<br>                    │                                                                        │<br>                    │  ┌─────────────────────┐                 ┌────────────────────────┐    │<br>                    │  │                     │                 │                        │    │<br>                    │  │      Interrupt      │                 │                        │    │<br>  Interrupt    ─────┼──┼─►       Handler     │                 │       Scheduler        │    │<br>     from Process   │  │                     │                 │                        │    │<br>  Interrupt    ─────┼──┼─►                   │                 │          │             │    │<br>     from I/O       │  └─────────────────────┘                 └──────────┼─────────────┘    │<br>                    │                                                     │                  │<br>                    │                                                     │                  │<br>                    │                                                     │                  │<br>                    └─────────────────────────────────────────────────────┼──────────────────┘<br>                                                                          │<br>                                                                          ▼<br>                                                                      Pass Control<br>                                                                          to Process<br></code></pre></td></tr></table></figure><h3 id="操作系统如何保护自己">操作系统如何保护自己</h3><p>答案是利用硬件提供的保护机制：</p><ul><li>CPU区分内核态和用户态，两种状态下，CPU能执行的指令集有所区别（禁止用户态执行可能威胁到操作系统的指令）</li><li>主存保护机制，使程序只能访问它有权访问的主存空间</li></ul><h2 id="操作系统分类">操作系统分类</h2><ul><li>批处理操作系统<ul><li>Batch Operating System，批量化处理作业</li><li>特点：<ul><li>用户脱机工作，将任务（作业）批量交给操作系统之后无需持续关注运行情况，操作系统将自动安排这些任务的输入和执行</li><li>成批处理作业（作业成批进入系统，全部完成后成批从系统输出结果）</li><li>多道程序运行（早期为单道）</li><li>作业周转时间长（一批作业在全部完成后才会被输出）</li></ul></li></ul></li><li>分时操作系统<ul><li>Time Sharing OperatingSystem，允许多个联机用户同时使用一台计算机系统进行计算的操作系统称分时操作系统。</li><li>特点<ul><li>同时性，多个用户同时</li><li>独立性，每个用户相对独立</li><li>及时性，快速响应用户请求</li><li>交互性，用户联机工作（这里指用户与作业的交互）</li></ul></li></ul></li><li>实时操作系统<ul><li>必须在一个事先定义好的时间限制内，对外部或内部的事件进行响应和处理的操作系统</li><li>按照满足条件的不同分为软实时系统和硬实时系统</li><li>例如信息查询、过程控制系统</li></ul></li></ul><h2 id="操作系统提供的服务和接口">操作系统提供的服务和接口</h2><ul><li>从完成功能的角度看，包括如下基本服务<ul><li>创建程序</li><li>执行程序</li><li>数据的输入输出</li><li>信息的存取</li><li>通信服务</li><li>错误检测和处理</li></ul></li><li>从提高系统效率角度看，增加如下服务<ul><li>资源分配</li><li>统计</li><li>保护</li></ul></li><li>操作系统通过提供接口向上层提供服务：<ul><li>用户接口（User Interface）<ul><li>命令行用户界面（Command Line User Interface, CLI），如Shell程序</li><li>图形用户界面（Graphic User Interface, GUI），如Windows用户界面</li></ul></li><li>程序接口（API，Application Interface），系统调用（System Call）<ul><li>API函数库（以API函数的形式提供系统调用，但API函数并不都进行系统调用）</li></ul></li></ul></li></ul><h2 id="操作系统的基本元素">操作系统的基本元素</h2><ul><li>内核，提供支持系统运行的基本功能和基本操作<ul><li>微内核</li><li>宏内核</li></ul></li><li>进程，资源分配的最小单位，CPU调度的单位</li><li>线程，CPU调度的最小单位</li></ul>]]></content>
    
    
    <categories>
      
      <category>操作系统</category>
      
    </categories>
    
    
    <tags>
      
      <tag>OS</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>常见排序算法及其时间复杂度</title>
    <link href="/2022/06/17/sort-alg/"/>
    <url>/2022/06/17/sort-alg/</url>
    
    <content type="html"><![CDATA[<h1 id="蛮力排序">蛮力排序</h1><p>这类算法通常原理简单，易于实现，但代价往往较高，有较大的提升空间。</p><h2 id="选择排序算法">选择排序算法</h2><p>算法总是在未排序的部分中寻找最大元素，之后将最大元素与未排序部分的末尾元素交换，最后扩大已排序部分。总而言之，该算法使已排序部分从末尾逐渐向前增长，直至排序完成。</p><p>伪代码如下，它将按照从小到大的顺序对A进行排序：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs python"><span class="hljs-keyword">def</span> <span class="hljs-title function_">selection_sort</span>(<span class="hljs-params">A: <span class="hljs-built_in">list</span></span>):<br>    <span class="hljs-keyword">for</span> i <span class="hljs-keyword">in</span> reverse(<span class="hljs-built_in">range</span>(<span class="hljs-built_in">len</span>(A))): <span class="hljs-comment"># i标识了当前未排序部分的末尾位置，因此i是逐步减小的</span><br>        index_max = get_max(A, <span class="hljs-number">0</span>, i) <span class="hljs-comment"># 取得未排序部分的最大元素</span><br>        swap(A[index_max], A[i]) <span class="hljs-comment"># 将未排序部分的最大元素放到末尾，从而扩大了已排序部分</span><br></code></pre></td></tr></table></figure><p>考虑到寻找最大元素的时间复杂度为<spanclass="math inline">\(O(n)\)</span>，而寻找最大元素的过程将进行<spanclass="math inline">\(n\)</span>次，因此总时间复杂度为<spanclass="math inline">\(O(n^2)\)</span>。</p><p>不难看出该算法无需额外开辟其他空间，所以它的空间复杂度为<spanclass="math inline">\(O(1)\)</span>，我们称这些空间复杂度为<spanclass="math inline">\(O(1)\)</span>的排序算法为原地排序算法。</p><h2 id="插入排序算法">插入排序算法</h2><p>这种算法可以利用到输入元素可能存在的有序性。算法总是从未排序部分取出一个元素，然后插入到已排序部分中。如果输入的元素已经具有一定有序性，那么操作次数将大大减少。</p><p>伪代码如下，它将按照从小到大的顺序对A进行排序：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><code class="hljs python"><span class="hljs-keyword">def</span> <span class="hljs-title function_">insertion_sort</span>(<span class="hljs-params">A: <span class="hljs-built_in">list</span></span>):<br>    <span class="hljs-keyword">for</span> i <span class="hljs-keyword">in</span> <span class="hljs-built_in">range</span>(<span class="hljs-number">1</span>, <span class="hljs-built_in">len</span>(A)): <span class="hljs-comment"># 开始时，将第一个元素视为已排序部分</span><br>        temp = A[i]<br>        j = i-<span class="hljs-number">1</span><br>        <span class="hljs-keyword">while</span> j&gt;=<span class="hljs-number">0</span> <span class="hljs-keyword">and</span> A[j]&gt;A[i]: <span class="hljs-comment"># 寻找合适的插入位置</span><br>            A[j+<span class="hljs-number">1</span>] = A[j] <span class="hljs-comment"># 为待插入元素腾位置</span><br>            j -= <span class="hljs-number">1</span><br>        A[j+<span class="hljs-number">1</span>] = temp<br></code></pre></td></tr></table></figure><p>可以看出，在输入元素相对有序时，代码中用于寻找插入位置的while循环部分将会减少执行次数。在输入元素完全有序（指输入与算法运行结果一致）时，用于寻找插入位置的while循环部分不会被执行，在此时，算法的时间复杂度为<spanclass="math inline">\(O(n)\)</span>。但是，在输入元素顺序与算法运行结果完全相反时，用于寻找插入位置的while循环部分总会执行j次，在这种情况下，算法的时间复杂度为<spanclass="math inline">\(O(n^2)\)</span>。</p><p>算法的平均时间复杂度为<spanclass="math inline">\(O(n^2)\)</span>。</p><h1 id="分治排序">分治排序</h1><p>分治策略的关键是对子问题的划分和对子问题解的合并。通常，根据这两个步骤的难易程度可以把分治算法分成“难分易合型”和“易分难合型”。通过分治，可以将排序的时间复杂度从<spanclass="math inline">\(O(n^2)\)</span>改进到<spanclass="math inline">\(O(nlogn)\)</span>，<spanclass="math inline">\(O(nlogn)\)</span>是基于比较的排序算法的最优时间复杂度。</p><h2 id="快速排序算法">快速排序算法</h2><p>算法首先选取一个基准元素（pivot），然后把比它小的元素放在它的左边，把比它大的元素放在它的右边，这样我们就得到了三个部分：小于pivot的元素，pivot，大于pivot的元素，此时pivot显然已经处于正确的位置，只需要对小于和大于pivot的元素递归地排序即可完成排序。</p><p>把小于pivot的元素，pivot和大于pivot的元素合起来是容易的（不需要其他操作），而把元素划分为小于pivot，pivot和大于pivot这三部分的操作却是复杂的，所以我们称这个算法是难分易合的算法。</p><p>伪代码如下，它将按照从小到大的顺序对A进行排序：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><code class="hljs python"><span class="hljs-keyword">def</span> <span class="hljs-title function_">partition</span>(<span class="hljs-params">A: <span class="hljs-built_in">list</span>, p, r</span>):<br>    pivot = A[r] <span class="hljs-comment"># 选择pivot，这里选择末尾元素作为pivot，也可以选择其他元素</span><br>    i = p-<span class="hljs-number">1</span> <span class="hljs-comment"># 标识小于pivot的部分，开始时没有元素小于pivot，所以是p-1</span><br>    <span class="hljs-keyword">for</span> j <span class="hljs-keyword">in</span> <span class="hljs-built_in">range</span>(p, r):<br>        <span class="hljs-keyword">if</span> A[j]&lt;pivot:<br>            i += <span class="hljs-number">1</span> <span class="hljs-comment"># &quot;开辟&quot;空间存放新的小于pivot的元素</span><br>            swap(A[j], A[i])<br>    <span class="hljs-comment"># 现在，A中从p到i存放着小于pivot的元素，而从i+1到r-1存放着大于pivot的元素，A[r]存放着pivot</span><br>    swap(A[i+<span class="hljs-number">1</span>], A[r]) <span class="hljs-comment"># 把pivot放到中间</span><br>    <span class="hljs-keyword">return</span> i+<span class="hljs-number">1</span> <span class="hljs-comment"># 返回pivot的位置</span><br><br><span class="hljs-keyword">def</span> <span class="hljs-title function_">quick_sort</span>(<span class="hljs-params">A: <span class="hljs-built_in">list</span>, p, r</span>):<br>    <span class="hljs-keyword">if</span> p&lt;r:<br>        pivot_idx = partition(A, p, r) <span class="hljs-comment"># 划分</span><br>        quick_sort(A, p, pivot_idx-<span class="hljs-number">1</span>) <span class="hljs-comment"># 对左半部分排序</span><br>        quick_sort(A, pivot_idx+<span class="hljs-number">1</span>, r) <span class="hljs-comment"># 对右半部分排序</span><br></code></pre></td></tr></table></figure><p>在分析时间复杂度时，假定每次划分是均匀的（把输入的数据平均分成两半），而划分的过程显然是<spanclass="math inline">\(\Theta(n)\)</span>的，那么可以得出时间复杂度的递推式<spanclass="math inline">\(T(n)=2T(n/2)+\Theta(n)\)</span>。根据MasterTheorem，<span class="math inline">\(E=log_22=1\)</span>，因此<spanclass="math inline">\(\Theta(n)\in\Theta(n^E)\)</span>，算法时间复杂度为<spanclass="math inline">\(\Theta(nlogn)\)</span>。</p><h2 id="合并排序归并排序">合并排序（归并排序）</h2><p>算法的整体思想是将所给的输入序列分成两半，然后对这两半递归地进行排序，之后合并两个已经有序的序列。这里对序列的划分显然是容易的（分成两半即可），而对两个有序序列的合并却是相对困难的，因此我们称这个算法是易分难合的算法。</p><p>在合并两个有序序列（这里指从小到大排列）时，我们总是对比两个序列的第一个元素，将其中较小的元素取出并放进最终的结果序列中，重复这个过程直到两个有序序列都为空，就完成了合并。</p><p>伪代码如下，它将按照从小到大的顺序对A进行排序：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><code class="hljs python"><span class="hljs-keyword">def</span> <span class="hljs-title function_">merge</span>(<span class="hljs-params">A: <span class="hljs-built_in">list</span>, p, q, r</span>):<br>    left_a = A[p:q+<span class="hljs-number">1</span>]<br>    right_a = A[q:r+<span class="hljs-number">1</span>] <span class="hljs-comment"># 取出两个有序的子序列</span><br>    left_a.append(inf)<br>    right_a.append(inf) <span class="hljs-comment"># 为了方便接下来的合并</span><br>    left = <span class="hljs-number">0</span><br>    right = <span class="hljs-number">0</span><br>    <span class="hljs-keyword">for</span> i <span class="hljs-keyword">in</span> <span class="hljs-built_in">range</span>(p, r+<span class="hljs-number">1</span>):<br>        <span class="hljs-keyword">if</span> left_a[left] &lt; right_a[right]:<br>            A[i] = left_a[left]<br>            left += <span class="hljs-number">1</span><br>        <span class="hljs-keyword">else</span>:<br>            A[i] = right_a[right]<br>            right += <span class="hljs-number">1</span><br>  <br><span class="hljs-keyword">def</span> <span class="hljs-title function_">merge_sort</span>(<span class="hljs-params">A: <span class="hljs-built_in">list</span>, p, r</span>):<br>    <span class="hljs-keyword">if</span> p&lt;r:<br>        q = (p+r)/<span class="hljs-number">2</span> <span class="hljs-comment"># 拆分</span><br>        merge_sort(A, p, q) <span class="hljs-comment"># 排序</span><br>        merge_sort(A, q+<span class="hljs-number">1</span>, r) <span class="hljs-comment"># 排序</span><br>        merge(A, p, q, r) <span class="hljs-comment"># 合并</span><br></code></pre></td></tr></table></figure><p>不难看出，合并（merge）部分的时间复杂度为<spanclass="math inline">\(\Theta(n)\)</span>，则可以写出归并排序时间复杂度的递推式<spanclass="math inline">\(T(n)=2T(n/2)+\Theta(n)\)</span>。根据MasterTheorem，<span class="math inline">\(E=log_22=1\)</span>，因此<spanclass="math inline">\(\Theta(n)\in\Theta(n^E)\)</span>，算法时间复杂度为<spanclass="math inline">\(\Theta(nlogn)\)</span>。</p>]]></content>
    
    
    <categories>
      
      <category>算法设计与分析</category>
      
    </categories>
    
    
    <tags>
      
      <tag>算法</tag>
      
      <tag>选择排序</tag>
      
      <tag>插入排序</tag>
      
      <tag>快速排序</tag>
      
      <tag>归并排序</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>Hello World</title>
    <link href="/2022/06/11/hello-world/"/>
    <url>/2022/06/11/hello-world/</url>
    
    <content type="html"><![CDATA[<center>Hello, world!</center>]]></content>
    
    
    <categories>
      
      <category>杂项</category>
      
    </categories>
    
    
    <tags>
      
      <tag>hello, world</tag>
      
    </tags>
    
  </entry>
  
  
  
  
</search>
