<?xml version="1.0" encoding="utf-8"?>
<search>
  
  
  
  <entry>
    <title>常见排序算法及其时间复杂度</title>
    <link href="/2022/06/17/sort-alg/"/>
    <url>/2022/06/17/sort-alg/</url>
    
    <content type="html"><![CDATA[<h1 id="蛮力排序"><a href="#蛮力排序" class="headerlink" title="蛮力排序"></a>蛮力排序</h1><p>这类算法通常原理简单，易于实现，但代价往往较高，有较大的提升空间。</p><h2 id="选择排序算法"><a href="#选择排序算法" class="headerlink" title="选择排序算法"></a>选择排序算法</h2><p>算法总是在未排序的部分中寻找最大元素，之后将最大元素与未排序部分的末尾元素交换，最后扩大已排序部分。总而言之，该算法使已排序部分从末尾逐渐向前增长，直至排序完成。</p><p>伪代码如下，它将按照从小到大的顺序对A进行排序：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs python"><span class="hljs-keyword">def</span> <span class="hljs-title function_">selection_sort</span>(<span class="hljs-params">A: <span class="hljs-built_in">list</span></span>):<br>    <span class="hljs-keyword">for</span> i <span class="hljs-keyword">in</span> reverse(<span class="hljs-built_in">range</span>(<span class="hljs-built_in">len</span>(A))): <span class="hljs-comment"># i标识了当前未排序部分的末尾位置，因此i是逐步减小的</span><br>        index_max = get_max(A, <span class="hljs-number">0</span>, i) <span class="hljs-comment"># 取得未排序部分的最大元素</span><br>        swap(A[index_max], A[i]) <span class="hljs-comment"># 将未排序部分的最大元素放到末尾，从而扩大了已排序部分</span><br></code></pre></td></tr></table></figure><p>考虑到寻找最大元素的时间复杂度为$O(n)$，而寻找最大元素的过程将进行$n$次，因此总时间复杂度为$O(n^2)$。</p><p>不难看出该算法无需额外开辟其他空间，所以它的空间复杂度为$O(1)$，我们称这些空间复杂度为$O(1)$的排序算法为原地排序算法。</p><h2 id="插入排序算法"><a href="#插入排序算法" class="headerlink" title="插入排序算法"></a>插入排序算法</h2><p>这种算法可以利用到输入元素可能存在的有序性。算法总是从未排序部分取出一个元素，然后插入到已排序部分中。如果输入的元素已经具有一定有序性，那么操作次数将大大减少。</p><p>伪代码如下，它将按照从小到大的顺序对A进行排序：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><code class="hljs python"><span class="hljs-keyword">def</span> <span class="hljs-title function_">insertion_sort</span>(<span class="hljs-params">A: <span class="hljs-built_in">list</span></span>):<br>    <span class="hljs-keyword">for</span> i <span class="hljs-keyword">in</span> <span class="hljs-built_in">range</span>(<span class="hljs-number">1</span>, <span class="hljs-built_in">len</span>(A)): <span class="hljs-comment"># 开始时，将第一个元素视为已排序部分</span><br>        temp = A[i]<br>        j = i-<span class="hljs-number">1</span><br>        <span class="hljs-keyword">while</span> j&gt;=<span class="hljs-number">0</span> <span class="hljs-keyword">and</span> A[j]&gt;A[i]: <span class="hljs-comment"># 寻找合适的插入位置</span><br>            A[j+<span class="hljs-number">1</span>] = A[j] <span class="hljs-comment"># 为待插入元素腾位置</span><br>            j -= <span class="hljs-number">1</span><br>        A[j+<span class="hljs-number">1</span>] = temp<br></code></pre></td></tr></table></figure><p>可以看出，在输入元素相对有序时，代码中用于寻找插入位置的while循环部分将会减少执行次数。在输入元素完全有序（指输入与算法运行结果一致）时，用于寻找插入位置的while循环部分不会被执行，在此时，算法的时间复杂度为$O(n)$。但是，在输入元素顺序与算法运行结果完全相反时，用于寻找插入位置的while循环部分总会执行j次，在这种情况下，算法的时间复杂度为$O(n^2)$。</p><p>算法的平均时间复杂度为$O(n^2)$。</p><h1 id="分治排序"><a href="#分治排序" class="headerlink" title="分治排序"></a>分治排序</h1><p>分治策略的关键是对子问题的划分和对子问题解的合并。通常，根据这两个步骤的难易程度可以把分治算法分成“难分易合型”和“易分难合型”。通过分治，可以将排序的时间复杂度从$O(n^2)$改进到$O(nlogn)$，$O(nlogn)$是基于比较的排序算法的最优时间复杂度。</p><h2 id="快速排序算法"><a href="#快速排序算法" class="headerlink" title="快速排序算法"></a>快速排序算法</h2><p>算法首先选取一个基准元素（pivot），然后把比它小的元素放在它的左边，把比它大的元素放在它的右边，这样我们就得到了三个部分：小于pivot的元素，pivot，大于pivot的元素，此时pivot显然已经处于正确的位置，只需要对小于和大于pivot的元素递归地排序即可完成排序。</p><p>把小于pivot的元素，pivot和大于pivot的元素合起来是容易的（不需要其他操作），而把元素划分为小于pivot，pivot和大于pivot这三部分的操作却是复杂的，所以我们称这个算法是难分易合的算法。</p><p>伪代码如下，它将按照从小到大的顺序对A进行排序：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><code class="hljs python"><span class="hljs-keyword">def</span> <span class="hljs-title function_">partition</span>(<span class="hljs-params">A: <span class="hljs-built_in">list</span>, p, r</span>):<br>    pivot = A[r] <span class="hljs-comment"># 选择pivot，这里选择末尾元素作为pivot，也可以选择其他元素</span><br>    i = p-<span class="hljs-number">1</span> <span class="hljs-comment"># 标识小于pivot的部分，开始时没有元素小于pivot，所以是p-1</span><br>    <span class="hljs-keyword">for</span> j <span class="hljs-keyword">in</span> <span class="hljs-built_in">range</span>(p, r):<br>        <span class="hljs-keyword">if</span> A[j]&lt;pivot:<br>            i += <span class="hljs-number">1</span> <span class="hljs-comment"># &quot;开辟&quot;空间存放新的小于pivot的元素</span><br>            swap(A[j], A[i])<br>    <span class="hljs-comment"># 现在，A中从p到i存放着小于pivot的元素，而从i+1到r-1存放着大于pivot的元素，A[r]存放着pivot</span><br>    swap(A[i+<span class="hljs-number">1</span>], A[r]) <span class="hljs-comment"># 把pivot放到中间</span><br>    <span class="hljs-keyword">return</span> i+<span class="hljs-number">1</span> <span class="hljs-comment"># 返回pivot的位置</span><br><br><span class="hljs-keyword">def</span> <span class="hljs-title function_">quick_sort</span>(<span class="hljs-params">A: <span class="hljs-built_in">list</span>, p, r</span>):<br>    <span class="hljs-keyword">if</span> p&lt;r:<br>        pivot_idx = partition(A, p, r) <span class="hljs-comment"># 划分</span><br>        quick_sort(A, p, pivot_idx-<span class="hljs-number">1</span>) <span class="hljs-comment"># 对左半部分排序</span><br>        quick_sort(A, pivot_idx+<span class="hljs-number">1</span>, r) <span class="hljs-comment"># 对右半部分排序</span><br></code></pre></td></tr></table></figure><p>在分析时间复杂度时，假定每次划分是均匀的（把输入的数据平均分成两半），而划分的过程显然是$\Theta(n)$的，那么可以得出时间复杂度的递推式$T(n)&#x3D;2T(n&#x2F;2)+\Theta(n)$。根据Master Theorem，$E&#x3D;log_22&#x3D;1$，因此$\Theta(n)\in\Theta(n^E)$，算法时间复杂度为$\Theta(nlogn)$。</p><h2 id="合并排序（归并排序）"><a href="#合并排序（归并排序）" class="headerlink" title="合并排序（归并排序）"></a>合并排序（归并排序）</h2><p>算法的整体思想是将所给的输入序列分成两半，然后对这两半递归地进行排序，之后合并两个已经有序的序列。这里对序列的划分显然是容易的（分成两半即可），而对两个有序序列的合并却是相对困难的，因此我们称这个算法是易分难合的算法。</p><p>在合并两个有序序列（这里指从小到大排列）时，我们总是对比两个序列的第一个元素，将其中较小的元素取出并放进最终的结果序列中，重复这个过程直到两个有序序列都为空，就完成了合并。</p><p>伪代码如下，它将按照从小到大的顺序对A进行排序：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><code class="hljs python"><span class="hljs-keyword">def</span> <span class="hljs-title function_">merge</span>(<span class="hljs-params">A: <span class="hljs-built_in">list</span>, p, q, r</span>):<br>    left_a = A[p:q+<span class="hljs-number">1</span>]<br>    right_a = A[q:r+<span class="hljs-number">1</span>] <span class="hljs-comment"># 取出两个有序的子序列</span><br>    left_a.append(inf)<br>    right_a.append(inf) <span class="hljs-comment"># 为了方便接下来的合并</span><br>    left = <span class="hljs-number">0</span><br>    right = <span class="hljs-number">0</span><br>    <span class="hljs-keyword">for</span> i <span class="hljs-keyword">in</span> <span class="hljs-built_in">range</span>(p, r+<span class="hljs-number">1</span>):<br>        <span class="hljs-keyword">if</span> left_a[left] &lt; right_a[right]:<br>            A[i] = left_a[left]<br>            left += <span class="hljs-number">1</span><br>        <span class="hljs-keyword">else</span>:<br>            A[i] = right_a[right]<br>            right += <span class="hljs-number">1</span><br>  <br><span class="hljs-keyword">def</span> <span class="hljs-title function_">merge_sort</span>(<span class="hljs-params">A: <span class="hljs-built_in">list</span>, p, r</span>):<br>    <span class="hljs-keyword">if</span> p&lt;r:<br>        q = (p+r)/<span class="hljs-number">2</span> <span class="hljs-comment"># 拆分</span><br>        merge_sort(A, p, q) <span class="hljs-comment"># 排序</span><br>        merge_sort(A, q+<span class="hljs-number">1</span>, r) <span class="hljs-comment"># 排序</span><br>        merge(A, p, q, r) <span class="hljs-comment"># 合并</span><br></code></pre></td></tr></table></figure><p>不难看出，合并（merge）部分的时间复杂度为$\Theta(n)$，则可以写出归并排序时间复杂度的递推式$T(n)&#x3D;2T(n&#x2F;2)+\Theta(n)$。根据Master Theorem，$E&#x3D;log_22&#x3D;1$，因此$\Theta(n)\in\Theta(n^E)$，算法时间复杂度为$\Theta(nlogn)$。</p>]]></content>
    
    
    <categories>
      
      <category>算法设计与分析</category>
      
    </categories>
    
    
    <tags>
      
      <tag>算法</tag>
      
      <tag>选择排序</tag>
      
      <tag>插入排序</tag>
      
      <tag>快速排序</tag>
      
      <tag>归并排序</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>Hello World</title>
    <link href="/2022/06/11/hello-world/"/>
    <url>/2022/06/11/hello-world/</url>
    
    <content type="html"><![CDATA[<center>Hello, world!</center>]]></content>
    
    
    <categories>
      
      <category>杂项</category>
      
    </categories>
    
    
    <tags>
      
      <tag>hello, world</tag>
      
    </tags>
    
  </entry>
  
  
  
  
</search>
