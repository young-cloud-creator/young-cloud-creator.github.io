<?xml version="1.0" encoding="utf-8"?>
<search>
  
  
  
  <entry>
    <title>Git基本原理和常用操作</title>
    <link href="/git-note/"/>
    <url>/git-note/</url>
    
    <content type="html"><![CDATA[<p>版本控制系统（Version ControlSystem）是一种用于记录文件（以及文件目录）的变化的工具。通过版本控制系统，我们可以了解文件（以及文件目录）的改动历史（谁在何时对文件做了什么更改），并能够随时将文件恢复到之前任何一个状态。版本控制系统为团队合作带来了便利，团队可以同时开发并在最后将各自的成果合并起来；而使用版本控制系统的个人也能利用它方便地管理自己的文件。</p><p>Git最初由林纳斯·托瓦兹创作，于2005年以GPL许可协议发布。最初目的是为了更好地管理Linux内核开发而设计。Git是目前最为主流的版本控制系统，它已经成为版本控制系统的事实标准（thede factostandard）。与CVS、SVN等集中式版本控制系统不同，Git是一个分布式版本控制系统，也就是说它不将项目的版本库存放在中央服务器上，而是在每一台计算机上都存放一个完整的项目版本库。</p><div class="note note-info">            <p>本文内容基于MIT的missing-semester课程中的Version Control(Git)一节，你可以在<ahref="https://missing.csail.mit.edu/2020/version-control/">https://missing.csail.mit.edu/2020/version-control/</a>找到完整的课程录像和讲义</p>          </div><h1 id="git基本原理">Git基本原理</h1><p>在Git的术语中，一个文件被称为一个blob，一个文件是一组字节的集合；一个目录被称为一个tree（树），一个tree可以包含若干blobs和若干trees；一个snapshot（快照）是项目的顶层tree（即代表项目根目录的tree）。</p><p>一个项目的不同版本的集合可以看作是若干个snapshot的集合，Git使用有向无环图（DirectedAcyclicGraph，DAG）来组织这些snapshot。在Git中，snapshot是一个commit的一部分，一个commit可以看作是一个包含更多信息的snapshot，每一个commit有若干个父commit。</p><p>例如，如果某个commit（记作B）直接由另一个commit（记作A）经过某些变化产生（比如在commitA的基础上修改了某些文件），那么commit B的父commit就只有一个，即commitA； <figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs None">A &lt;-- B<br></code></pre></td></tr></table></figure>而如果某个commit是由两个（或更多）commit合并而来，那么该commit的父commit就不止一个。比如commitA修改了文件A，commitB修改了文件B，现在我们通过一个commit（记作C）合并这两个commit，即创建一个既修改了文件A又修改了文件B的commit，那么这个commit的父commit就是commitA和commit B。 <figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs None"><br>A &lt;---- C<br>       /<br>      v<br>      B<br></code></pre></td></tr></table></figure>commit在创建之后就不能被修改，它所代表的是项目的修改历史，如果你要修改文件，只需要在某个或某几个commit的基础上创建一个新的commit。</p><h2 id="数据结构">数据结构</h2><p>上面的描述可能比较模糊，下面用伪代码描述blob、tree和commit的数据结构。<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><code class="hljs None">type blob = array&lt;byte&gt; //一个文件也就是blob是由若干字节构成的<br><br>//一个目录也就是tree包含若干个tree和blob<br>//为了区分这些不同的tree或者blob，需要一个字符串来标识它们（可以理解为文件名/目录名）<br>type tree = map&lt;string, tree | blob&gt;<br><br>//一个commit包含它的父commit（当然，实际上存储的是父commit的标识而非父commit本身）<br>//以及一些其他信息（例如commit的作者、commit的信息）<br>//和对顶层目录的snapshot（实际上存储的是snapshot的标识而非snapshot本身）<br>type commit = struct &#123;<br>    parents: array&lt;commit&gt;<br>    author: string<br>    message: string<br>    snapshot: tree<br>&#125;<br></code></pre></td></tr></table></figure></p><p>现在定义object，一个object可以是blob、tree或者commit。 <figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs None">type object = blob | tree | commit<br></code></pre></td></tr></table></figure>在Git中，object统一使用SHA-1进行哈希，以哈希值作为object的地址。这样，tree对其包含的tree和blob的存储，实际上是存储这些tree和blob的地址（哈希值）。在终端中，可以通过<code>git cat-file -p</code>加上object的哈希值得到object。</p><h2 id="引用-reference">引用 Reference</h2><p>现在，尽管可以通过SHA-1哈希值访问object，但是这显然是不方便的，毕竟这一长串哈希值对人类来说不过是无意义的乱码，它难以被记忆和使用。Git对此的解决方法是通过<strong>引用（reference）</strong>，reference是一个类似<code>map&lt;string, string&gt;</code>的映射，它将名字（人类可读的字符串）与哈希值相绑定，从而使人类可以通过有意义的名字访问object。常见的reference例子是Git的分支名，Git的分支其实是指向某个commit的reference，通过<code>git checkout</code>，人类可以方便地使用有意义的分支名访问到某个特定commit。例如，<code>master</code>往往指向项目主分支的最新的一个commit，而<code>HEAD</code>则是指向当前所在的commit。</p><h2 id="仓库-repository">仓库 Repository</h2><p>前面介绍了Git中的一些基本名词（blob、tree、commit、object、reference等）。粗略来说，Git仓库就是object和reference的集合，Git命令的实质是在commit构成的DAG中对object和reference进行操作，比如,如果想要修改<code>master</code>引用，使<code>master</code>引用指向哈希值为<code>5d83f9e</code>的commit，对应的Git命令是<code>git checkout master; git reset --hard 5d83f9e</code>。</p><h2 id="暂存区-staging-area">暂存区 Staging Area</h2><p>前面提到，一个项目的不同版本可以看作是一系列snapshot的集合，但Git并不是简单地创建当前状态的snapshot，而是给予用户更大的自主权，在创建snapshot时，Git允许用户挑选具体哪些更改将被保存到这一snapshot，比如，用户可以一次性实现两个功能，但为这两个功能分别创建一个snapshot。</p><p>为了实现上面的特性，Git提供了暂存区机制，用户将更改加入到暂存区，然后为暂存区中的所有更改创建一个snapshot（也就是commit）。这样，用户可以自由选择哪些更改将被加入到下一次commit，这种对更改的选择甚至可以具体到文件的某一行内容。</p><h1 id="git常用操作">Git常用操作</h1><p>这里列出常用的Git操作，更具体的可以参考<ahref="https://git-scm.com/book/en/v2"><u>ProGit</u></a>、使用<code>git help</code>或者参考其他Git教程。</p><h2 id="基础操作">基础操作</h2><ul><li><code>git help &lt;command&gt;</code>获取帮助/获取具体某一命令的帮助</li><li><code>git init</code> 创建一个新的空Git仓库</li><li><code>git status</code>查看当前情况（有无文件被修改、有无新文件、暂存区情况等）</li><li><code>git add &lt;filename&gt;</code> 将文件加入暂存区<ul><li><code>git add -p &lt;filename&gt;</code>进入交互模式，更具体地指定要加入暂存区的内容</li></ul></li><li><code>git commit</code> 创建一个commit</li><li><code>git log</code> 以扁平模式展示历史commit记录<ul><li><code>git log --graph</code>以DAG方式展示历史commit记录，可以看到commit之间的关系</li></ul></li><li><code>git diff &lt;filename&gt;</code>查看文件相较于暂存区内容（或HEAD指向的commit）的区别<ul><li><code>git diff &lt;revision&gt; &lt;filename&gt;</code>查看文件在不同commit之间的区别，<code>&lt;revision&gt;</code>可以是branch的名字、commit的哈希值，如果<code>&lt;revision&gt;</code>只有一个branch名字或者commit哈希值，则会比较其指向的commit与当前commit的文件差异</li></ul></li><li><code>git checkout &lt;revision&gt;</code>更新HEAD，使其指向<code>&lt;revision&gt;</code>指出的commit，从而使项目目录变成<code>&lt;revision&gt;</code>指出的commit时的状态，可以用来切换分支、查看项目历史状态等</li></ul><h2 id="分支相关操作">分支相关操作</h2><p>分支的操作本质是对代表分支的reference的操作，例如切换分支是修改HEAD指向分支的reference，创建分支是创建一个指向HEAD指向的commit的新reference</p><ul><li><code>git branch</code> 列出所有分支<ul><li><code>git branch &lt;name&gt;</code>创建一个名为<code>&lt;name&gt;</code>的分支</li></ul></li><li><code>git checkout &lt;name&gt;</code>切换至<code>&lt;name&gt;</code>分支<ul><li><code>git checkout -b &lt;name&gt;</code>创建并切换至<code>&lt;name&gt;</code>分支，等同于<code>git branch &lt;name&gt;; git checkout &lt;name&gt;</code></li></ul></li><li><code>git merge &lt;revision&gt;</code>合并分支/commit到当前分支</li><li><code>git mergetool</code>使用mergetool来处理合并时的冲突（conflict）<ul><li>mergetool使用前需要自己在gitconfig中指定mergetool，一般有vimdiff、beyondCompare、diffmerge等多种工具</li><li>mergetool帮助用户查看冲突所在，用户可以选择冲突两方中的一方内容作为最终内容，也可以选择冲突两方最近共同祖先的内容或者自己手动编辑内容，从而解决冲突</li></ul></li><li><code>git rebase</code>merge操作将创建一个新的commit，父commit指向merge的分支；而rebase则会临时保存当前分支从与要合并分支的共同祖先开始的每一个commit记录作为patch（补丁），然后将当前分支reference指向要合并的分支，然后把保存的补丁逐个进行commit。<ul><li>如下所示， <figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><code class="hljs None">before:<br>A &lt;- B &lt;- C(branch A)<br>     ^<br>      \<br>        D &lt;- E(branch B)<br>        <br>after:<br>A &lt;- B &lt;- C(branch A) &lt;- D&#x27; &lt;- E&#x27;(branch B)<br>     ^<br>      \<br>        D(throw away) &lt;- E(throw away)<br></code></pre></td></tr></table></figure></li><li><code>git rebase -i</code> 交互式rebase</li></ul></li></ul><h2 id="远程仓库相关操作">远程仓库相关操作</h2><ul><li><code>git remote</code> 列出所有与当前仓库绑定的远程仓库<ul><li><code>git remote add &lt;name&gt; &lt;url&gt;</code>添加远程仓库</li></ul></li><li><code>git push &lt;remote&gt; &lt;local branch&gt;:&lt;remote branch&gt;</code>向指定远程仓库的指定分支推送本地指定分支的objects</li><li><code>git branch --set-upstream-to=&lt;remote&gt;/&lt;remote branch&gt;</code>设置当前所在的本地分支与远程分支的绑定，从而之后可以直接使用<code>git push</code>命令而无需指定分支</li><li><code>git fetch</code> 从远程仓库获取objects/reference信息</li><li><code>git pull</code>等同于<code>git fetch; git merge</code>，即从远程仓库获取信息后，合并本地分支与远程分支</li><li><code>git clone &lt;remote&gt; &lt;localpath&gt;</code>从远程下载整个仓库</li></ul><h2 id="撤销相关操作">撤销相关操作</h2><ul><li><code>git commit --amend</code> 编辑commit的信息</li><li><code>git reset HEAD &lt;file&gt;</code> 取消对文件更改的暂存</li><li><code>git checkout -- &lt;file&gt;</code> 放弃对文件的更改</li></ul><h2 id="其他">其他</h2><ul><li><code>git config</code> Git是高度自定义的，可以自定义你的Git</li><li><code>git clone --depth=1</code>浅克隆，只下载远程仓库的最新版本而非整个版本库</li><li><code>git blame</code> 查看具体文件中某行的作者信息</li><li><code>git stash</code> 暂时移除对仓库的未commit的修改<ul><li><code>git stash pop</code>恢复之前通过<code>git stash</code>暂时移除的修改</li></ul></li><li><code>git bisect</code> 二分搜索版本历史</li><li><code>.gitignore</code>通过该文件指出有意不通过Git追踪的文件，从而在Git操作时忽略它们</li></ul><div class="note note-info">            <p><strong>如何写好git commit message：</strong><ahref="https://tbaggery.com/2008/04/19/a-note-about-git-commit-messages.html">https://tbaggery.com/2008/04/19/a-note-about-git-commit-messages.html</a>、<ahref="https://cbea.ms/git-commit/">https://cbea.ms/git-commit/</a></p><p><strong>一些常见的Git错误操作和它们的补救措施：</strong><ahref="https://ohshitgit.com">https://ohshitgit.com</a></p>          </div>]]></content>
    
    
    <categories>
      
      <category>Git</category>
      
    </categories>
    
    
    <tags>
      
      <tag>Git</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>操作系统 并发控制</title>
    <link href="/os-concurrency/"/>
    <url>/os-concurrency/</url>
    
    <content type="html"><![CDATA[<h1 id="并发控制概论">并发控制概论</h1><p>一组进程在执行时间上重叠，一个进程执行的第一条指令可能是在另一个进程执行的最后一条指令完成之前开始的，这就是进程的并发性。从宏观来看，一个时间段中有多个进程同时处于活动状态，而从微观来看，任一时刻仅有一个进程在处理器上运行。综上，进程并发的实质是一个CPU在多个进程之间的多路复用。</p><h2 id="并发程序间的关系">并发程序间的关系</h2><ul><li>无关<ul><li>不同的并发进程在不同的变量集合上操作，一个进程的执行与其他并发进程的执行无关</li><li>进程读取的变量集合<spanclass="math inline">\(R(P)=\{a_1,a_2,...a_n\}\)</span>，进程改变的变量集合<spanclass="math inline">\(W(P)=\{b_1,b_2,...,b_n\}\)</span>，如果两个进程<spanclass="math inline">\(P_1\)</span>、<spanclass="math inline">\(P_2\)</span>的变量集合满足<spanclass="math inline">\((R(P_1)\cap W(P_2))\cup (R(P_2)\cap W(P_1))\cup(W(P_1)\capW(P_2))=\emptyset\)</span>，那么这两个进程就是无关的。这个条件叫做Bernstein条件。</li></ul></li><li>交互<ul><li>一组并发进程（线程）共享某些变量，一个进程的执行可能影响其他并发进程的执行</li><li>竞争关系（间接制约）<ul><li>解决手段：进程互斥访问同一共享资源，即任何时刻最多允许一个进程访问某一共享资源，其他进程需要等到该进程释放资源后才能访问该资源</li></ul></li><li>协作关系（直接制约）<ul><li>解决手段：进程同步，即通过某个条件（或变量）协调多个进程的活动，进程在需要依赖另一个进程的工作时进入等待状态，直到另一个进程发出信号时再被唤醒执行</li></ul></li><li>进程互斥是一种特殊的进程同步（互斥锁）</li></ul></li></ul><h2 id="并发程序的优缺点">并发程序的优缺点</h2><p>优点：</p><ul><li>对于单处理器系统，可以让处理器与I/O设备同时工作，提高效率</li><li>对于多（核）处理器系统，可以让各个进程在不同的处理器（核心）上并行执行，加快计算速度</li><li>简化了程序设计任务（更接近于现实世界：某事和某事同时发生）</li></ul><p>缺点：</p><ul><li>对于有一组有交互关系的并发进程，如果不加管理，可能会出现一些与时间有关的错误出现，例如永远等待、结果不一致等。</li></ul><h1 id="临界区管理">临界区管理</h1><ul><li>临界区：并发进程中与共享变量有关的程序段称之为临界区</li><li>临界资源：共享变量代表的资源</li><li>临界区管理：保证一个进程在<strong>某一资源的临界区</strong>执行时，不让另一个进程进入相关的临界区，从而实现对共享变量的互斥访问。</li><li>临界区调度的原则<ul><li>一次至多有一个进程能够进入某一临界区</li><li>不能让一个进程无限地留在临界区（其他进程无法推进）</li><li>无空等待，有空让进，择一而入</li></ul></li><li>临界区的嵌套可能造成进程无法离开临界区（发生死锁）<ul><li>如：region X do {...; region Y do {...};...}（进入X的临界区，然后在X的临界区进入Y的临界区）。如果有另一进程执行regionY do {...; region X do {...}; ...}则可能出现两个进程死锁的现象。</li></ul></li></ul><h2 id="软件方式">软件方式</h2><h3 id="dekker算法">Dekker算法</h3><p>基本思想：进程进入临界区前，首先把自己的标识置为true，然后检查对方标识和临界区指示器turn，如果对方标识为true且指示器turn指向对方，则等待；否则进入临界区，在离开临界区时，修改自己的标识为false并把指示器指向对方。</p><h3 id="peterson算法">Peterson算法</h3><p>基本思想：进程进入临界区前，首先把自己的标识置为true，然后令指示器指向对方，之后检查对方标识和指示器，如果对方标识为true且指示器指向对方，则等待；否则进入临界区，在离开临界区时，修改自己的标识为false。</p><h2 id="硬件方式">硬件方式</h2><p>硬件提供相关指令以实现自旋锁，常用于内核临界区管理（例如：TSL测试并置位指令，该指令将lock变量原值复制到寄存器，然后将lock变量置为1；又例如：XCHG对换指令，将两个变量的值交换，借助该指令可以实现自旋锁）</p><p>自旋锁很少被用于用户层，因为自旋锁依赖于忙等待（等待时需要不断检查自旋锁状态）所以效率低下（持续占用CPU资源），而持续占用CPU资源检查自旋锁又可能会造成操作系统误判进程状态进而分配更多CPU资源</p><h1 id="同步问题">同步问题</h1><ul><li><p>一个典型的进程同步问题：有若干个生产者和若干个消费者，它们共享一个缓冲区，生产者生产数据放入缓冲区，消费者从缓冲区取走数据。因此，需要解决生产者与消费者、生产者与生产者、消费者与消费者之间的同步问题，例如：当前缓冲区状态（空/满），从何处取数据，能不能取数据（不能有多个消费者同时取走同一份数据），能不能放数据（不能有多个生产者同时向同一位置存放数据）等。</p></li><li><p>解决方法：进程之间通过交换<strong>信号</strong>或<strong>消息</strong>来达到进程协调运行的目的</p></li><li><p>常见的同步机制</p><ul><li>信号量与PV操作</li><li>管程</li><li>消息传递</li></ul></li></ul><h1 id="信号量与pv操作">信号量与PV操作</h1><p>基于之前对自旋锁的讨论可以看出，自旋锁需要占用较多的系统资源来进行忙等待，所以通常只被用于操作系统内核。对于用户层程序，通常使用由操作系统提供的同步机制来进行进程间的同步。</p><p><strong>原语：P（荷兰语：Proberen，测试），V（荷兰语：Verhogen，增量）</strong>，除了对信号量赋初值外，信号量仅能通过以上两个原语进行操作。P操作首先会测试信号量是否大于0，如果大于0，则会将信号量减一，否则将等待信号量大于0后再减一；V操作会将信号量加一。</p><p>信号量分类：</p><ul><li><p>按用途</p><ul><li>公有信号量（进程互斥）<ul><li>多个进程均可以对该信号量进行PV操作，从而实现互斥（例如：初始化信号量为1，进入临界区前先对该信号量做P操作，离开临界区后再对该信号量做V操作）</li></ul></li><li>私有信号量（进程同步）<ul><li>某个进程只对该信号量进行P操作和V操作中的一种，从而实现进程同步（例如：如果进程A在某处需要依赖于进程B的工作，则初始化信号量为0，在进程A需要进程B工作的地方先进行P操作，B进程在完成任务后进行V操作，这样就实现了A和B的同步）</li></ul></li></ul></li><li><p>按取值</p><ul><li><p>二元信号量（只有0/1，用于进程互斥）</p></li><li><p>一般信号量（初始值可以为任意非负整数，用于进程互斥或进程同步）</p><div class="note note-info">            <p>一般信号量可以由二元信号量构造产生</p>          </div></li></ul></li><li><p>按结构</p><ul><li>整形信号量<ul><li>信号量s为一非负整数，P(s)在s大于0时将s减一，否则持续等待，直至s大于0，V(s)将信号量加一</li></ul></li><li>记录型信号量<ul><li>信号量s包含两个分量：value和queue，queue用于记录等待的进程，当value小于等于0时执行P操作，进程将会被加入queue中；当value小于0时执行V操作，系统将会唤醒queue中某个等待的进程</li></ul></li></ul></li></ul><p>当信号量的值为正时，该值可以看作当前可用的资源数量；当信号量的值为负时，该值的绝对值可以看作当前正在等待资源的进程数量。P操作可以看作请求一个资源，V操作可以看作释放一个资源。</p><h1 id="管程">管程</h1><p>使用信号量和PV操作实现同步时，对共享资源的管理分散在各进程中，这可能容易造成程序设计错误，因此出现了管程这一机制。</p><p>管程的基本思想时把分散在各进程中的临界区集中进行管理（类似于面向对象编程中的<strong>类</strong>），并把系统中的共享资源用数据结构抽象地表示出来。管程是程序设计语言地一种结构成分，和信号量具有同等的表达能力，管程是一种同步逻辑的封装机制，通过封装好的管程，编写程序不再需要考虑共享资源的同步问题。（例如，如果有一个封装好的容器类对象，在编写多线程程序时，各个线程无需考虑对该容器类对象的同步或互斥访问问题，只需要调用容器类封装好的存取函数）</p><p>管程体内的各个函数均是互斥进行的，即在任意时刻，只有一个进程位于管程体内，所以编写管程时无需考虑互斥访问的问题。</p><ul><li>条件变量：用于阻塞进程的一种信号量</li><li>wait原语：当一个管程过程无法继续时，对某个<strong>条件变量</strong>执行wait原语，这将会使调用该管程过程的进程阻塞</li><li>signal原语：用于唤醒阻塞在某一条件变量上的某个进程，此时存在执行signal的进程与被唤醒进程同时位于管程体内的问题，这与管程的互斥性相悖，有两种解决方法：<ul><li>执行signal的进程等待，直到被唤醒的进程退出管程（完成执行或需要等待其他条件变量）（Hoare实现）</li><li>被唤醒的进程等待，直到执行signal的进程退出管程（完成执行或需要等待其他条件变量）（Mesa实现）</li><li>对signal执行的位置做出限制，只允许在管程体函数末尾执行signal操作（Hanson实现）</li></ul></li></ul><h2 id="管程实现">管程实现</h2><ul><li><p>Hoare实现</p><ul><li><p>采用<strong>执行signal的进程等待，直到被唤醒的进程退出管程</strong>的方法解决互斥性问题，使用PV操作实现进程间的互斥</p></li><li><p>实现方法：引入两个信号量mutex和next，其中mutex用于实现进程互斥调用管程过程，初始化为1；next用于让执行signal的进程挂起自己，初始化为0。引入计数器next_count，用于记录在信号量next上等待的进程数。对于每个条件变量，设置一个初始化为0的信号量x_sem和一个记录等待该条件变量进程数量的计数器x_count。</p><ul><li><p>具体实现代码如下所示：</p><figure><img src="/illustration/os-concurrency/hoare.png"alt="Hoare方法实现管程" /><figcaption aria-hidden="true">Hoare方法实现管程</figcaption></figure></li><li><p>对于外部过程，需要通过如下方式保证管程的互斥性：</p><figure><img src="/illustration/os-concurrency/hoare-mutex.png"alt="Hoare方法实现管程" /><figcaption aria-hidden="true">Hoare方法实现管程</figcaption></figure></li><li><p>文字描述：在使用管程体的任何一个函数之前，首先要通过P操作申请管程使用权（以实现互斥访问），在申请到权限后进入管程体执行各种操作，操作完成后优先将控制权转移给因为signal操作而主动挂起的进程，如果没有这样的进程则释放控制权给其他进程（即释放互斥锁）。</p><ul><li>如果需要等待某个条件变量则使用wait操作，wait操作首先将x_count加一（以记录该条件变量上等待的进程数），之后就可以释放控制权给其他进程了，在这里优先释放控制权给之前因为signal操作而主动挂起的进程，如果没有这样的进程则释放控制权给其他进程（即释放互斥锁），在释放控制权之后，执行P操作以等待被唤醒，唤醒后将x_count减一（同样为了记录该条件变量上等待的进程数）。</li><li>如果需要向某个条件变量进行signal操作，则首先检查有没有等待该条件变量的进程，如果没有，signal操作无效；否则先将next_count加一（以记录自己的挂起），然后释放控制权给等待条件变量的某个进程，最后通过P操作等待自己被唤醒，唤醒后将next_count减一。</li></ul></li></ul></li></ul></li></ul><h1 id="进程通信">进程通信</h1><p>常见的通信机制：</p><ul><li>信号通信</li><li>共享文件</li><li>共享存储区</li><li>消息传递</li></ul><h2 id="信号通信">信号通信</h2><p>信号通信又称软中断，是一种简单的通信机制，通过发送一个特定的信号来通知进程某个异常事件发生，信号可以是内核发送给进程，也可以是一个进程发送给另一个进程。</p><div class="note note-info">            <p>之前的文章中也提到了信号机制，<ahref="/os-schedule/#信号机制"><strong>点击这里查看</strong></a></p>          </div><h2 id="共享文件">共享文件</h2><p>也叫管道通信，通过一个特殊的称之为<strong>管道</strong>（pipeline）的共享文件连接两个读写进程，管道允许进程按照先进先出的方式<strong>单向</strong>传送数据。</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><code class="hljs None">                                +------------------------------+<br>                                |                              |<br>+-------------+                 |                              |             +---------------+<br>|             |    byte stream  |                              | byte stream |               |<br>|  Process 1  +----------------&gt;|           pipeline           +-----------&gt; |   Process 2   |<br>|   (Write)   |                 |                              |             |     (Read)    |<br>+-------------+                 |                              |             +---------------+<br>                                |                              |<br>                                +------------------------------+<br></code></pre></td></tr></table></figure><p>共享文件可以借助于文件系统的机制实现，包括管道文件的创建、打开、关闭以及读写。进程对共享文件互斥使用，即一个进程正在读或写时，另一个进程必须等待。共享文件的大小是有限制的，因此通信双方需要正确同步（在共享文件装满之前取走数据，以避免后来的数据无法写入而造成进程阻塞）。</p><h3 id="有名管道">有名管道</h3><p>普通的匿名管道（PIPE）仅能连接具有共同祖先的进程（通过fork继承管道文件的访问权限），并且具有临时性，难以提供全局服务。在UNIX中，有名管道（FIFO）作为一种永久性通信机制具有UNIX文件名、访问权限，并且性能与普通管道相同（数据被读取后消失，即先进先出FIFO）。</p><div class="note note-info">            <p>关于有名管道和匿名管道，也可以看看<ahref="https://blog.csdn.net/qq_36016407/article/details/53818280">https://blog.csdn.net/qq_36016407/article/details/53818280</a></p>          </div><h2 id="共享存储区">共享存储区</h2><p>共享存储区是进程通信中最快捷和有效的方法，具体过程是：进程向系统共享存储区申请一个分区段，并指定关键字；若系统已为其他进程分配了该分区，则返回对应的关键字给申请者。分区段连接到进程的虚拟空间，进程可以通过对该区段的读/写来实现通信。</p><h2 id="消息传递">消息传递</h2><p>基本概念：消息是一组信息，由消息头和消息体组成。通过send和receive两个消息传递原语实现进程间通信，通常是异步send（即不必等到接收方receive再发送），同步receive（即必须等发送方send后才能接收）。常见的做法是构建消息队列（消息的链表），并由消息队列标识符标识一个队列。</p><h1 id="死锁">死锁</h1><p>死锁是指因为某些原因导致进程始终获取不到所需的资源（或者无法满足某些条件）而永远处于等待状态的现象。一组进程处于死锁状态是指：如果在一个进程集合中得每个进程都在等待只能由该集合中其他一个进程才能引发的事件，则称一组进程或系统此时发生了死锁。</p><h2 id="死锁举例">死锁举例</h2><h3 id="进程推进顺序不当产生死锁">进程推进顺序不当产生死锁</h3><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs None">进程P进程Q<br>1.请求读卡机1.请求打印机<br>2.请求打印机2.请求读卡机<br>......<br>产生死锁的执行顺序：P1-&gt;Q1-&gt;P2-&gt;Q2<br></code></pre></td></tr></table></figure><h3 id="pv操作使用不当产生死锁">PV操作使用不当产生死锁</h3><p>与上一例类似，即某个进程先对信号量a执行P操作，再对信号量b执行P操作；另一个进程先对信号量b执行P操作，再对信号量a执行P操作，两个进程均因为第二个P操作无法满足而阻塞不前，发生死锁。</p><h3 id="同类资源分配不当产生死锁">同类资源分配不当产生死锁</h3><p>5个同类资源，5个请求进程，每个进程需要请求2个资源才能继续执行。如果按照轮流分配，每次分配一个资源的分配方式将导致死锁。</p><h3id="对临时性资源使用不加限制产生死锁">对临时性资源使用不加限制产生死锁</h3><p>在进程通信中，消息作为临时性资源如果使用不当将发生死锁。例如：</p><ul><li>P1等待P3的消息到达后向P2发送消息</li><li>P2等待P1的消息到达后向P3发送消息</li><li>P3等待P2的消息到达后向P1发送消息</li></ul><h2 id="死锁的防止">死锁的防止</h2><p>死锁存在的四个必要条件（Coffman，1971）：</p><ul><li>互斥条件</li><li>占有和等待条件</li><li>不剥夺条件</li><li>循环等待条件</li></ul><p>常见的死锁防止方法：</p><ul><li>静态分配策略，破坏第二个条件</li><li>层次分配策略，破坏第四个条件</li></ul><h2 id="死锁的避免">死锁的避免</h2><p>破坏死锁存在的条件往往会导致低效的程序运行和较低的资源使用率，因此尝试通过对每一次资源申请进行分析来判断是否会造成死锁，从而避免死锁的发生。</p><h3 id="常见算法">常见算法</h3><ul><li>资源轨迹图<ul><li>略</li></ul></li><li>银行家算法<ul><li>前提条件<ul><li>每个进程必须事先说明自己对每种资源所要求的最大数量，并承诺在获得所需的资源后能够在有限时间内归还</li><li>进程可以分多次向系统申请所需资源</li></ul></li><li>算法的关键是对进程发出的资源申请做出判断，因此又称“资源分配拒绝法”</li><li>算法对于一次资源申请的判断依据是，如果同意该申请，是否存在一个安全状态序列使所有进程最终均能获得所需的资源，如果存在则可以同意此次资源申请，否则拒绝此次申请</li><li>缺陷：<ul><li>进程很难在运行前知道自己所需资源的最大数量</li><li>算法要求系统中各进程必须是无关的，即没有同步要求</li><li>算法无法处理进程数量和资源数量动态变化的情况</li></ul></li></ul></li></ul><h2 id="死锁的检测">死锁的检测</h2><p>使用资源分配图：</p><ul><li>描述进程和资源间申请及分配关系的一种有向图，图中顶点分为进程和资源两种，一条进程-&gt;资源的有向边为申请边，代表进程申请资源，一条资源-&gt;进程的有向边为分配边，代表资源被分配给进程。</li><li>对于每种资源只有一个实例的情况，如果资源分配图中出现环则意味着出现死锁</li><li>对于有资源存在多个实例的情况，首先需要进行化简：如果某个进程满足了所有需要的资源（出度为0），则将它占有的资源全部释放，从而变成一个孤立的点，释放的资源转而分配给其他需要的进程。重复该过程，知道资源分配图无法继续化简，如果图中没有边，则没有死锁发生，否则出现了死锁，图中所有非孤立的进程就是发生死锁的进程</li></ul><h2 id="死锁的解除">死锁的解除</h2><ul><li>终止所有死锁进程</li><li>一次终止一个进程，直到死锁解除</li><li>逐步从进程占用的资源中抢夺资源给其他进程使用，直到死锁解除</li></ul>]]></content>
    
    
    <categories>
      
      <category>操作系统</category>
      
    </categories>
    
    
    <tags>
      
      <tag>OS</tag>
      
      <tag>并发控制</tag>
      
      <tag>管程</tag>
      
      <tag>死锁</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>操作系统 处理器管理</title>
    <link href="/os-schedule/"/>
    <url>/os-schedule/</url>
    
    <content type="html"><![CDATA[<h1 id="处理器管理">处理器管理</h1><p>处理器管理是操作系统的中药组成部分之一，负责<strong>管理</strong>、<strong>调度</strong>和<strong>分派</strong>处理器资源以及<strong>控制程序的执行</strong>。处理器管理主要涉及两部分的内容：<strong>处理器资源的分配</strong>和<strong>运行的程序（进程）调度</strong>。</p><h1 id="处理器基础知识">处理器基础知识</h1><ul><li><p>处理器主要由控制器、运算器、寄存器、中断装置以及高速缓存（Cache）等组成</p></li><li><p>处理器的寄存器包括通用寄存器、数据寄存器、地址寄存器和控制寄存器等多个寄存器</p></li><li><p>机器指令（简称指令）是指示计算机执行某些操作的命令，一台计算机所有指令的集合称为<strong>指令集</strong>。</p><ul><li>按照指令复杂程度和指令数量可以将计算机分为<strong>复杂指令集计算机（ComplexInstruction SetComputer，CISC）</strong>和<strong>精简指令集计算机（Reduced InstructionSet Computer，RISC）</strong>两种</li><li>指令按照使用者可以分为特权指令（仅供操作系统内核使用的指令）和非特权指令两种</li></ul></li><li><p>为了防止普通用户使用特权指令，处理器需要区分当前运行的代码属于操作系统内核还是属于普通程序，所以处理器具有不同的状态，简单来说分为<strong>管理状态</strong>（也称特权状态、系统状态、特态、管态）和<strong>用户状态</strong>（也称目标状态、用户模式、常态、目态）两种。管理状态时CPU能够执行指令集支持的所有指令，而在用户状态时CPU只能执行非特权指令。</p><ul><li>处理器状态的转换通常通过中断（包括外部设备中断、应用程序的系统调用以及程序运行过程中发生的错误等）来完成</li></ul></li><li><p>程序状态字（Program StatusWord，PSW）用于存储不同程序的处理器工作状态，每个处理器均有一组与程序执行相关的寄存器，这组寄存器就是当前该处理器上所运行程序的程序状态字。程序状态字通常包括程序的基本状态（例如下一条指令地址、状态位、条件码等），中断码和中断屏蔽位。</p><div class="note note-info">            <p>借助程序状态字以及其他信息，操作系统能够记录当前并发运行的多个程序的状态，从而能够在这些程序之间无缝切换</p>          </div></li></ul><h1 id="中断技术">中断技术</h1><p>中断是用来向CPU报告某设备已完成某项操作的手段，它是并发程序的基础。当中断到来时，CPU将会暂停正在运行的程序，转而执行该中断的相关处理程序。中断的处理需要由<strong>硬件</strong>（中断装置，用于监测中断并在中断到来时保护现场、跳转到中断处理程序）和<strong>软件</strong>（中断处理程序）相互配合完成。</p><p>中断可以按照性质分为以下两种：</p><ul><li>强迫性中断，例如发生机器故障、程序运行发生错误、外部设备中断等</li><li>自愿性中断，例如程序主动使用系统调用</li></ul><p>中断可以按照中断信号的来源分为以下两种：</p><ul><li>外中断（中断），中断信号来自外部设备，例如时钟中断（由定时器发出）、输入输出设备中断等<ul><li>外中断与现行指令无关，通常可以被屏蔽、可以嵌套，只有在两条指令之间才能响应中断</li></ul></li><li>内中断（异常），中断信号来自机器自身，例如非法指令、缺页错误、算术操作溢出、校验错等<ul><li>内中断由现行指令引发，可以在一个指令周期被处理，通常不可屏蔽（不处理该中断程序无法继续运行）、不可嵌套。可以细分为<strong>出错</strong>（例如缺页错误，处理完成后回到出错指令处执行）和<strong>陷入</strong>（例如系统调用，处理完成后执行陷入指令的下一条指令）</li></ul></li></ul><div class="note note-info">            <p>硬件如何找到中断处理程序——通过中断向量表（Interrupt VectorTable，IVT）</p>          </div><h2 id="中断事件处理的一般过程">中断事件处理的一般过程</h2><ul><li>Step 1：发现中断源（由硬件完成）</li><li>Step 2：初步保护现场（由硬件完成）</li><li>Step 3：转到中断处理程序（软件）执行<ul><li>Step 3.1：进一步保护现场</li><li>Step 3.2：执行中断处理相关代码</li><li>Step 3.3：恢复部分现场（由软件保护的现场）</li></ul></li><li>Step 4：恢复现场（硬件完成，恢复由硬件保护的现场）</li></ul><h2 id="中断的优先级">中断的优先级</h2><p>在同时有多个中断发生时，中断装置需要按照一定的顺序对其做出响应，这个顺序由优先级决定。优先级通常按照对计算机影响的严重程度设定，在处理高优先级的中断时，可以屏蔽低优先级的中断。</p><p>在中断处理过程中，如果又产生了新的中断，有如下几种不同的处理策略：</p><ul><li>串行处理<ul><li>在处理中断时不管其他中断，中断按照串行顺序逐个被处理</li><li>可以通过关中断实现</li></ul></li><li>嵌套处理<ul><li>先暂停当前的中断处理过程，转而处理更高优先级的中断</li></ul></li><li>即时处理<ul><li>主要针对中断处理程序执行过程中发生的程序性中断，如果不处理，中断处理程序无法继续运行</li></ul></li></ul><h2 id="信号机制">信号机制</h2><p>一种模拟硬件中断的进程间简单通信机制（软件中断），例如：Ctrl+C结束程序运行是由内核向进程发送了SIGINT信号。</p><ul><li>内核向进程（进程发生异常，内核向其通知）</li><li>进程向进程（进程间通信，发送某个事件）</li></ul><div class="note note-info">            <center><strong>POSIX定义的信号类型</strong></center><p><a href="https://zh.wikipedia.org/wiki/SIGABRT">SIGABRT</a> · <ahref="https://zh.wikipedia.org/wiki/SIGALRM">SIGALRM</a> · <ahref="https://zh.wikipedia.org/wiki/SIGFPE">SIGFPE</a> · <ahref="https://zh.wikipedia.org/wiki/SIGHUP">SIGHUP</a> · <ahref="https://zh.wikipedia.org/wiki/SIGILL">SIGILL</a> · <ahref="https://zh.wikipedia.org/wiki/SIGINT_(POSIX)">SIGINT</a> · <ahref="https://zh.wikipedia.org/wiki/SIGKILL">SIGKILL</a> · <ahref="https://zh.wikipedia.org/wiki/SIGPIPE">SIGPIPE</a> · <ahref="https://zh.wikipedia.org/wiki/SIGQUIT">SIGQUIT</a> · <ahref="https://zh.wikipedia.org/wiki/記憶體區段錯誤">SIGSEGV</a> · <ahref="https://zh.wikipedia.org/wiki/SIGTERM">SIGTERM</a> · <ahref="https://zh.wikipedia.org/wiki/SIGUSR1和SIGUSR2">SIGUSR1</a> · <ahref="https://zh.wikipedia.org/wiki/SIGUSR1和SIGUSR2">SIGUSR2</a> · <ahref="https://zh.wikipedia.org/wiki/子进程">SIGCHLD</a> · <ahref="https://zh.wikipedia.org/wiki/SIGCONT">SIGCONT</a> · <ahref="https://zh.wikipedia.org/w/index.php?title=SIGSTOP&amp;action=edit&amp;redlink=1">SIGSTOP</a>· <ahref="https://zh.wikipedia.org/w/index.php?title=SIGTSTP&amp;action=edit&amp;redlink=1">SIGTSTP</a>· <ahref="https://zh.wikipedia.org/w/index.php?title=SIGTTIN&amp;action=edit&amp;redlink=1">SIGTTIN</a>· <ahref="https://zh.wikipedia.org/w/index.php?title=SIGTTOU&amp;action=edit&amp;redlink=1">SIGTTOU</a>· <a href="https://zh.wikipedia.org/wiki/总线错误">SIGBUS</a> · <ahref="https://zh.wikipedia.org/w/index.php?title=SIGPOLL&amp;action=edit&amp;redlink=1">SIGPOLL</a>· <ahref="https://zh.wikipedia.org/w/index.php?title=SIGPROF&amp;action=edit&amp;redlink=1">SIGPROF</a>· <a href="https://zh.wikipedia.org/wiki/SIGSYS">SIGSYS</a> · <ahref="https://zh.wikipedia.org/w/index.php?title=SIGTRAP&amp;action=edit&amp;redlink=1">SIGTRAP</a>· <ahref="https://zh.wikipedia.org/w/index.php?title=SIGURG&amp;action=edit&amp;redlink=1">SIGURG</a>· <ahref="https://zh.wikipedia.org/w/index.php?title=SIGVTALRM&amp;action=edit&amp;redlink=1">SIGVTALRM</a>· <ahref="https://zh.wikipedia.org/w/index.php?title=SIGXCPU&amp;action=edit&amp;redlink=1">SIGXCPU</a><ahref="https://zh.wikipedia.org/w/index.php?title=SIGXFSZ&amp;action=edit&amp;redlink=1">SIGXFSZ</a></p>          </div><h1 id="进程">进程</h1><p>进程（Process）是一个<strong>可并发执行</strong>的具有独立功能的<strong>程序</strong>关于某个<strong>数据集合</strong>的一次<strong>执行过程</strong>，也是操作系统进行<strong>资源分配和保护的基本单位</strong>。</p><p>从理论角度来看，进程是对正在运行的程序活动规律的抽象。从实现角度来看，进程是刻画程序运行状态和系统动态变化的一种数据结构。</p><p>通过进程可以发挥系统的并发性，提高资源利用率，换言之，进程是并发程序设计的工具。此外，进程能够解决同一段代码的共享性的问题，它能够正确描述程序的执行状态（标识程序的多次运行）。</p><h2 id="进程的状态和转换">进程的状态和转换</h2><p>进程的五态模型如下所示（忽略这糟糕的排版），</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><code class="hljs None">┌───────────────┐<br>│               │<br>│     新建态     │<br>│               │<br>└──────┬────────┘<br>       │<br>       │ 分配资源、加载程序<br>       │<br>       ▼<br>┌───────────────┐ 调度程序选中   ┌────────────────┐         ┌─────────────────┐<br>│               ├─────────────►│                │ 运行完成 │                 │<br>│     就绪态     │              │     运行态      ├────────►│     终止态       │<br>│               │◄─────────────┤                │         │                 │<br>└───────────────┘     落选      └───────┬────────┘         └─────────────────┘<br>       ▲                               │<br>       │                               │出现等待事件（例如Sleep）<br>       │                               │<br>       │                               ▼<br>       │                       ┌─────────────────┐<br>       │                       │                 │<br>       └───────────────────────┤      等待态      │<br>        等待结束                │                 │<br>                               └─────────────────┘<br></code></pre></td></tr></table></figure><p>进程挂起是指将进程对换到外部存储器（例如：磁盘）上，释放器占有的系统资源（例如：内存），排除在进程调度之外。这样做的目的是提高系统资源利用率，减轻系统负载或者用于调试程序。</p><p>具有挂起状态的状态转换模型如下所示（忽略这糟糕的排版），</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><code class="hljs None">┌───────────────┐        ┌────────────────┐<br>│               │  提交   │                │            等待事件结束<br>│     新建态     ├───────►│    挂起就绪态    │◄──────────────────────────────────────────┐<br>│               │        │                │                                           │<br>└──────┬────────┘        └────┬───────────┘                                           │<br>       │          解除挂起      │  ▲    ▲                                               │<br>  提交  │  ┌───────────────────┘  │    │                                               │<br>       │  │                      │    │                                               │<br>       │  │  ┌───────────────────┘    │ 挂起                                           │<br>       ▼  ▼  │    挂起                 │                                               │<br>┌────────────┴──┐              ┌──────┴─────────┐         ┌─────────────────┐         │<br>│               ├─────────────►│                │         │                 │         │<br>│    就绪态      │              │     运行态      ├────────►│      终止态      │         │<br>│               │◄─────────────┤                │         │                 │         │<br>└───────────────┘              └───────┬────────┘         └─────────────────┘         │<br>       ▲                               │                                              │<br>       │                               │ 等待事件                                      │<br>       │                               │                                              │<br>       │                               ▼                                              │<br>       │                       ┌─────────────────┐  挂起     ┌───────────────┐         │<br>       │                       │                 ├────────► │               │         │<br>       └───────────────────────┤      等待态      │          │    挂起等待态   ├─────────┘<br>           等待事件结束          │                 │◄─────────┤               │<br>                               └─────────────────┘ 解除挂起  └───────────────┘<br></code></pre></td></tr></table></figure><h2 id="进程的结构">进程的结构</h2><p>进程的内存映像包括进程控制块（Process ControlBlock，PCB）、核心堆栈（供内核态使用）、用户堆栈（供用户态使用）以及用户私有地址空间（代码段、数据段等）和共享地址空间。</p><p>进程的物理实体和支持进程运行的环境合称为进程上下文，因此进程的上下文切换就是进程的切换。它包括：</p><ul><li>用户级上下文<ul><li>程序段、数据段、用户堆栈、共享存储区等</li></ul></li><li>寄存器上下文<ul><li>程序状态字（PSW）寄存器、栈指针寄存器、通用寄存器等</li></ul></li><li>系统级上下文<ul><li>进程控制块、主存管理信息（如页表、段表等）、核心堆栈</li></ul></li></ul><p>每个进程有且仅有一个<strong>进程控制块</strong>，它存储着进程标识信息、进程现场信息（通用寄存器、PSW寄存器等寄存器的值）以及进程控制信息（调度信息、通信信息、资源信息等）。</p><p>一个进程控制块刻画了一个进程的运行状态，而进程控制块的集合则刻画了一个操作系统当前的运行状态。进程控制块的使用和修改只能由操作系统内核来完成。</p><p>进程队列将同一状态（例如：等待队列、就绪队列）的所有进程控制块链接在一起，以便于操作系统进行统一的管理和调度。</p><h2 id="进程控制">进程控制</h2><h3 id="进程创建">进程创建</h3><p>常见原语：fork，clone，……</p><ul><li>fork：用于创建子进程，创建出的进程与原进程是父子进程关系</li><li>clone：用于创建进程，创建出的进程与原进程是对等关系</li></ul><p>创建过程：</p><ul><li>申请PCB（进程控制块）</li><li>分配进程映像空间</li><li>分配资源</li><li>将进程内容装入分配空间</li><li>初始化PCB，分配唯一标识</li><li>加入就绪队列或投入运行</li><li>通知操作系统其他模块</li></ul><h3 id="进程阻塞与唤醒">进程阻塞与唤醒</h3><p>常见原语（阻塞）：wait，waitpid，sleep，……</p><p>进程阻塞过程：</p><ul><li>保存现场到PCB</li><li>修改进程状态（运行态-&gt;等待态）</li><li>将PCB加入<strong>相应的</strong>等待队列</li><li>转到进程调度程序，调度执行其他进程</li></ul><p>进程唤醒过程：</p><ul><li>从<strong>相应的</strong>等待队列中取出PCB</li><li>修改进程状态（等待态-&gt;就绪态）</li><li>将PCB加入就绪队列</li><li>转到进程调度程序，或继续执行原进程</li></ul><h3 id="进程终止">进程终止</h3><p>常见原语：exit</p><p>终止过程：</p><ul><li>根据进程标识找到对应的PCB</li><li>将该进程资源归还给父进程或操作系统</li><li>若有子进程，则终止所有子（孙）进程</li><li>将PCB移出队列，将PCB归还给PCB池</li></ul><h1 id="线程">线程</h1><p>从上面的讨论可以发现，以进程为单位的并发程序效率不高，存在着进程时空开销大（调度和进程切换时间长，空间占用大），通信代价高（需要借助操作系统），进程间并发粒度大等问题。</p><p>为了解决这些问题，将进程<strong>独立分配资源</strong>和<strong>独立分派调度</strong>这两项功能分离出来，就产生了<strong>线程</strong>（Thread）的概念。一个进程的多个线程共享同一个用户地址空间，但同时每个进程拥有自己独立的堆栈空间和指令执行序列，这样，同一进程的不同线程既可以访问相同的共享变量（存储于进程的数据空间中），又能够互不干扰地各自执行指令（拥有独立的堆栈和寄存器）。</p><p>在多线程环境下，<strong>进程</strong>是操作系统中进行保护和资源分配的基本单位，而<strong>线程</strong>是处理器调度和分配的基本单位，同一进程的所有线程共享进程获得的主存空间和资源。</p><h2 id="线程的管理与实现">线程的管理与实现</h2><p>基本的线程管理原语：</p><ul><li>thread_create 创建线程</li><li>thread_join 等待线程</li><li>thread_yield 出让（主动让出线程自身的执行机会）</li><li>thread_exit 终止线程</li></ul><p>线程的实现方式分为内核级线程，用户级线程和前两者的混合实现，如下所示，</p><p><img src="\illustration\os-schedule\线程实现.png" alt="线程的三种实现" style="zoom: 67%;" /></p><ul><li>内核级线程<ul><li>由内核管理的线程</li><li>优点<ul><li>能够在多个处理器上同时执行多个线程</li><li>某个进程中一个线程被阻塞，不会影响其他线程的运行</li></ul></li><li>缺点<ul><li>线程间切换代价高，需要涉及两次模式切换（用户态-&gt;内核态内核态-&gt;用户态）</li></ul></li></ul></li><li>用户级实现<ul><li>用户线程的建立、同步、销毁、调度完全在用户空间完成，不需要内核的帮助</li><li>优点<ul><li>线程切换不涉及模式切换，代价小</li><li>调度算法选择灵活（由进程自行调度）</li></ul></li><li>缺点<ul><li>同一进程的不同线程不能同时在多个处理器上运行</li><li>一个线程的阻塞将导致整个进程的阻塞</li><li>非抢占式调度</li></ul></li><li>改进机制<ul><li>upcall机制</li><li>非阻塞系统调用，增加select系统调用</li></ul></li></ul></li><li>混合实现<ul><li>例如将若干个用户线程绑定到一个内核线程上</li><li>设计得当，可结合前两者的优点</li><li>设计不当，将产生更差的效果</li></ul></li></ul><div class="note note-info">            <p>内核提供一组虚拟处理器(LWP)给应用程序，应用程序可调度用户线程到一个可用的虚拟处理器上。内核需要告知用户该线程的运行状态，这个过程被称为<strong>upcall</strong>。详见<ahref="https://blog.csdn.net/weixin_42250655/article/details/103571820">https://blog.csdn.net/weixin_42250655/article/details/103571820</a></p>          </div><h2 id="并发多线程程序设计的优点">并发多线程程序设计的优点</h2><ul><li>易于实现多个活动间的通信（共享变量）</li><li>更低的管理开销</li><li>I/O密集型应用能获得更好的性能</li><li>能更好地利用多（核）处理器，加快程序执行</li></ul><h1 id="处理器调度">处理器调度</h1><p>处理器调度的主要内容是：</p><ul><li>挑选作业进入内存</li><li>在进程（线程）之间分配处理器时间</li></ul><p>处理器调度可以分为：</p><ul><li>高级调度（作业调度、长程调度），为提交的作业分配资源，决定作业是否进入主存（即决定提交的作业置为就绪态还是挂起就绪态）</li><li>中级调度（平衡负载调度、中程调度），决定哪些作业（进程）留在主存中，控制外存和内存的对换（例如，挂起-&gt;解除挂起）</li><li>低级调度（进程/线程调度、短程调度），决定进程/线程是否占用处理器执行（例如，就绪-&gt;运行）</li></ul><h2 id="高级调度">高级调度</h2><p>在多道批处理系统中，高级调度的工作：</p><ul><li>后备作业-&gt;进程</li><li>作业准备-&gt;启动-&gt;善后工作</li></ul><p>在分时系统中，高级调度的工作：</p><ul><li>是否接受一个终端用户的连接</li><li>交互作业能否被接纳，并创建进程</li></ul><h2 id="中级调度">中级调度</h2><ul><li>控制主存储器中容纳的进程数</li><li>保证在合理数目的进程，竞争处理器和相关资源</li></ul><div class="note note-info">            <p>挂起的进程不参与低级调度</p>          </div><h2 id="低级调度">低级调度</h2><p>存在两种调度方式：</p><ul><li>抢占方式（剥夺方式）<ul><li>优先级抢占</li><li>限时抢占</li></ul></li><li>非抢占方式（非剥夺方式）</li></ul><p>抢占方式调度的开销通常大于非抢占方式，但是可以避免一个进程或线程长时间独占处理器。</p><h2 id="调度算法">调度算法</h2><p>任何层次的处理器调度均由操作系统相应的调度程序实施，调度程序所使用的算法，被称为调度算法。</p><h3 id="调度算法考虑的主要因素">调度算法考虑的主要因素</h3><ul><li>资源利用率 -&gt; 不要让CPU空转<ul><li>CPU有效工作时间/CPU总运行时间</li></ul></li><li>响应时间<ul><li>从作业提交到收到回应的时间</li></ul></li><li>周转时间<ul><li>作业提交到作业完成的时间</li><li>平均周转时间、平均带权周转时间</li></ul></li><li>吞吐率<ul><li>单位时间处理的作业数</li></ul></li><li>公平性<ul><li>确保每个进程获得合理的资源份额</li></ul></li></ul><h3 id="典型高级调度算法">典型高级调度算法</h3><h4 id="先来先服务-first-come-first-served-fcfs">先来先服务 First-ComeFirst-Served FCFS</h4><p>按照作业进入系统的作业后备队列的先后次序挑选作业，先进入系统的作业优先被选择</p><ul><li>优点<ul><li>实现简单</li></ul></li><li>缺点<ul><li>不利于短作业而优待长作业（先到达的长作业周转时间短于后到达的短作业）</li><li>效率低</li></ul></li></ul><h4 id="最短作业优先算法-sjf">最短作业优先算法 SJF</h4><p>以进入系统的作业所要求的CPU时间长短为标准，总是挑选时间最短的作业投入运行</p><ul><li>优点<ul><li>实现简单</li><li>效率相对较高</li></ul></li><li>缺点<ul><li>在实际系统中，往往难以预测作业的CPU时间</li><li>长作业等待时间可能会过长（持续有短作业进入系统，长作业将难以得到服务）</li></ul></li></ul><h4 id="最短剩余时间优先-srtf">最短剩余时间优先 SRTF</h4><p>每次调度时，总选择预测剩余运行时间最短的作业优先运行</p><ul><li>优点<ul><li>效率相对较高</li></ul></li><li>缺点<ul><li>调度频繁</li><li>剩余运行时间难以预测</li><li>长作业等待时间可能过长</li></ul></li></ul><h4 id="响应比最高优先算法-hrrf">响应比最高优先算法 HRRF</h4><p>响应比=作业周转时间（响应时间）/作业预计计算时间=(作业预计计算时间+作业等待时间)/作业预计计算时间</p><p>总是选择响应比最高的作业投入运行，从而防止了作业等待时间过长的“饥饿”现象发生</p><h3 id="典型低级调度算法">典型低级调度算法</h3><h4 id="先来先服务-first-come-first-served-fcfs-1">先来先服务 First-ComeFirst-Served FCFS</h4><p>非抢占式调度方式，可以使用就绪队列实现先进先出，但是效率不高，不利于I/O频繁操作的进程（一发生I/O就被移至就绪队列队尾，从而需要等待较长时间才能再次执行）</p><h4 id="时间片轮转-round-robin">时间片轮转 Round-Robin</h4><p>抢占式调度方式，基本原理是利用时钟中断轮流执行各进程</p><ul><li>分类<ul><li>基本时间片轮转法，各进程时间片相同</li><li>动态时间片轮转法，各进程时间片不同</li></ul></li><li>时间片选取<ul><li>时间片过长-&gt;FCFS</li><li>时间片过短-&gt;调度频繁，效率不高</li></ul></li></ul><h4 id="优先数调度-priority-scheduling">优先数调度 PriorityScheduling</h4><p>抢占（高优先级进程抢占低优先级进程）和非抢占式（低优先级进程无法抢占高优先级进程）调度方式。总是取优先级最大的进程执行</p><ul><li>分类<ul><li>静态优先数</li><li>动态优先数<ul><li>基本原则：一个进程连续占用处理器的时间越长，则其优先数越小；一个进程等待处理器的时间越长，则其优先数越大</li><li>计算优先数需要占用较多的CPU时间，为降低调度开销，应选择合适的时机和合适的计算对象</li><li>具体细节可以参考早期UNIX调度算法的实现</li></ul></li></ul></li></ul><h4 id="最短进程优先-shortest-process-first">最短进程优先 ShortestProcess First</h4><p>下次持续执行时间短的进程优先。</p><ul><li>下次持续执行时间的估算使用<strong>老化（aging）算法</strong>，即<spanclass="math inline">\(aT_0+(1-a)T_1\)</span>，其中<spanclass="math inline">\(a\)</span>为老化系数。</li></ul><h4 id="多级反馈队列调度-multiple-queues">多级反馈队列调度 MultipleQueues</h4><p>基本思想：将就绪队列分为多级队列，较高的队列分配时间片较短，但是具有较高的优先权占有处理器；较低的队列分配时间片较长，但是占有处理器的优先权较低。同一队列的进程按照先来先服务的原则进行调度。进程的分级可以静态分级也可以动态分级。</p><h4 id="保证调度-guaranteed-scheduling">保证调度 GuaranteedScheduling</h4><p>基本思想：对每个进程做出性能保证，并在调度中尽力实现该保证。例如，在有n个进程时，保证每个进程获得1/n的处理器能力，那么调度时总是优先执行实际获得处理器时间与应得处理器时间差距最大的进程。</p><h4 id="彩票调度-lottery-scheduling">彩票调度 Lottery Scheduling</h4><p>基本思想：为进程发放针对系统资源的“彩票”，当调度程序选择进程时，随机选择一张“彩票”，持有该“彩票”的进程将被选择。这样，进程持有的彩票越多，它被分配系统资源的概率就越大。</p><h2 id="实时系统及其调度算法">实时系统及其调度算法</h2><p>实时系统的计算正确性不仅取决于计算的逻辑正确性，还取决于产生结果的时间。如果未满足系统的时间约束，则认为系统失效。也就是说，实时系统对响应时间具有特殊要求，在这类系统中，时间是非常关键的因素。</p><ul><li>分类<ul><li>软实时系统：提供统计意义上的实时。例如，有的应用要求系统在95%的情况下都会确保在规定的时间内完成某个动作，而不一定要求100%</li><li>硬实时系统：实时性必须达到100%，例如卫星发射系统、核反应堆控制系统等</li></ul></li><li>构成<ul><li>将程序分为多个进程，每个进程负责处理相应的周期性事件</li></ul></li><li>特点<ul><li>规模小，进程切换快，处理时间短，能够管理多个高精度计时器</li></ul></li></ul><h3 id="可调度">可调度</h3><p>可调度是指在忽略调度本身所花费CPU时间的前提下，系统能够在各事件规定的响应时间内处理完成这些事件。</p><p>对于周期事件，可以使用下面的公式判断系统是否可调度：</p><ul><li><span class="math inline">\(C_1/P_1+C_2/P_2+...+C_m/P_m\le1\)</span>，其中<span class="math inline">\(m\)</span>为事件总数，<spanclass="math inline">\(C_i\)</span>为某个事件的处理时间，<spanclass="math inline">\(P_i\)</span>为事件发生的周期</li></ul><h3 id="典型实时调度算法">典型实时调度算法</h3><h4 id="单比率调度算法静态">单比率调度算法（静态）</h4><p>令进程的优先级与对应事件出现频率成正比，该算法理论上最优</p><h4 id="限期调度算法动态">限期调度算法（动态）</h4><p>进程的就绪队列按照对应事件的截止期限排序</p><h4 id="最少裕度调度算法动态">最少裕度调度算法（动态）</h4><p>裕度=截止时间-(就绪时间+计算时间)，该算法总是选择裕度最小的进程优先执行</p>]]></content>
    
    
    <categories>
      
      <category>操作系统</category>
      
    </categories>
    
    
    <tags>
      
      <tag>OS</tag>
      
      <tag>调度算法</tag>
      
      <tag>CPU</tag>
      
      <tag>进程</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>操作系统 概论</title>
    <link href="/os-overview/"/>
    <url>/os-overview/</url>
    
    <content type="html"><![CDATA[<h1 id="计算机系统">计算机系统</h1><p>计算机系统通常包括计算机硬件（Hardware）、操作系统（OperatingSystem）和应用程序（Application）以及用户（User）几个部分；操作系统运行在计算机硬件上，而应用程序依赖于操作系统向上层提供的一系列服务和接口运行，最后，用户使用应用程序完成自己的工作；这些部分之间的关系如下所示。</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><code class="hljs None"> ┌──────────────┐   ┌───────────────┐                 ┌──────────────┐<br> │     USER1    │   │     USER2     │    ... ...      │     USERn    │<br> └───────┬──────┘   └───────┬───────┘                 └───────┬──────┘<br>         │                  │                                 │<br>         ▼                  ▼                                 ▼<br>┌─────────────────────────────────────────────────────────────────────┐<br>│                                                                     │<br>│                             APPLICATION                             │<br>│                                                                     │<br>│         ┌────────────────────────────────────────────────┐          │<br>│         │                                                │          │<br>└─────────┤                OPERATING SYSTEM                ├──────────┘<br>          │                                                │<br>          │        ┌───────────────────────────────┐       │<br>          └────────┤                               ├───────┘<br>                   │           HARDWARE            │<br>                   │                               │<br>                   └───────────────────────────────┘<br></code></pre></td></tr></table></figure><p>可以看到，从硬件向上到应用程序，它们的覆盖范围是逐层加大的。可以这样理解：操作系统通过各种方法扩展和增强了硬件的功能（例如虚拟内存机制的使用，在应用程序层面来看扩充了实际内存的大小；又例如分时多任务机制的使用，在用户层面来看有多个程序在同时运行，但实际的处理器数量并没有这么多）；而应用程序又利用操作系统提供的各种接口和服务进一步扩展和增强了计算机的功能（例如五花八门的应用程序让用户通过计算机完成各种任务，而不仅限于计算）。</p><h1 id="操作系统">操作系统</h1><p>计算机系统是一个具有层次结构的系统，<strong>操作系统是处于硬件和应用程序中间的软件，它向上为应用程序提供简洁易用的资源抽象，屏蔽复杂的底层逻辑；向下管理种类繁多的硬件资源</strong>。</p><h2 id="功能和目标">功能和目标</h2><h3 id="功能">功能</h3><ul><li>资源管理（包括处理器管理、存储管理、设备管理、文件管理等）</li><li>控制执行（例如进程调度、进程的并发控制等）</li><li>提供接口（例如作业管理提供了向计算机输入作业的接口）</li></ul><h3 id="目标">目标</h3><ul><li>方便用户使用</li><li>提升机器能力（例如：并发控制使得单核处理器计算机也能“同时”运行多个程序）</li><li>提高运行效率（例如：并发有效利用了处理器资源）</li><li>提供开放环境（例如：操作系统提供了一个可供应用程序运行的开放环境）</li></ul><h2 id="主要特征">主要特征</h2><h3 id="并发性">并发性</h3><ul><li>并发是指两个或两个以上事件在<strong>同一时间间隔内</strong>发生。并发提高了资源利用率（一心多用），但是增加了管理复杂度（例如为了保证程序之间不相互影响而对资源进行的保护，等等）</li><li>支持并发的操作系统称之为多任务系统</li></ul><div class="note note-info">            <p>并行是指两个或两个以上事件或活动在<strong>同一时刻</strong>发生，它是并发的特例。</p>          </div><h3 id="共享性">共享性</h3><ul><li>共享性是指系统中的资源可被多个并发执行的任务（作业）所使用</li><li>两类共享方式：<ul><li>互斥访问（适用于某一时刻只能被一个任务访问的资源，例如打印机、屏幕输出等）</li><li>同时访问（适用于某一时刻可以被多个任务访问的资源，例如读取文件内容、读取传感器数据等）</li></ul></li></ul><h3 id="异步性">异步性</h3><ul><li>主要表现<ul><li>任务执行的时间、推进速度等不定（例如，每个程序执行的时间可能是不相同的）</li><li>事件发生的不可预期，如各种中断的发生（例如，我现在按了一下键盘的某个键）</li></ul></li><li>对操作系统的要求<ul><li>能够处理随机发生的各种事件</li><li>在不同的事件序列中，确保任务的正确执行（例如，程序不能因为我插了个耳机就崩溃了）</li></ul></li></ul><h3 id="虚拟性">虚拟性</h3><ul><li>虚拟性是操作系统中的一种管理技术，是指将物理上的一个实体变成逻辑上的多个对应物，或将物理上的多个实体变成逻辑上的一个对应物的技术。</li><li>例如，虚拟内存（将逻辑上的一个个内存块映射到不同的内存或磁盘空间中）</li></ul><h2 id="操作系统运行机制概览">操作系统运行机制概览</h2><h3 id="从接通电源到操作系统">从接通电源到操作系统</h3><h4 id="step-1接通电源运行bios">Step 1：接通电源，运行BIOS</h4><p>接通电源后，CPU首先会执行一条跳转指令，这条指令将会使CPU跳转BIOS代码继续执行，BIOS在进行一系列初始化和自检工作（该过程被称为POST过程）后，执行自举过程，该过程将第一阶段引导程序的代码（是主引导记录的一部分）从磁盘指定位置（磁盘的首个扇区）调入到内存中，随后跳转到第一阶段引导程序继续执行。</p><div class="note note-info">            <p>BIOS的全称是Basic Input OutputSystem，它是硬件厂商在硬件上自带的一段启动的代码，作用是进行一些硬件检查，并且跳转到引导程序bootloader。</p>          </div><div class="note note-info">            <p>引导程序，英文为Bootloader，引导在英文中为“boot”，是bootstrap的缩写，源自于短语“Pulloneself up by one'sbootstraps”，即“靠自己振作起来”。引导程序的任务是将另一段程序代码加载到内存中。</p>          </div><div class="note note-info">            <p>主引导记录，英文为Master BootRecord，简称MBR，又称主引导扇区，记录着引导程序代码和硬盘本身的相关信息以及硬盘各个分区的大小及位置信息。</p>          </div><h4 id="step-2第一阶段引导程序加载第二阶段引导程序">Step2：第一阶段引导程序加载第二阶段引导程序</h4><p>第一阶段引导程序经由BIOS加载并开始执行，而第一阶段引导程序将会把第二阶段引导程序加载到内存中，然后跳转到第二阶段引导程序。这么做的原因是第一阶段引导程序的大小受到限制（因为它存储在主引导记录中，而主引导记录仅有一个扇区大小），无法完成复杂的功能。</p><h4 id="step-3第二阶段引导程序加载操作系统">Step3：第二阶段引导程序加载操作系统</h4><p>第二阶段引导程序不再拘于一个扇区大小，因此可以完成更复杂的功能，它将会把操作系统内核（Kernel）加载到内存中，最终把计算机的控制权交给操作系统内核。常见的第二阶段引导程序有LILO、GRUB等。</p><div class="note note-info">            <p>对于UEFI系统，由EFI应用程序（即EFI系统分区中的<code>.efi</code>文件）取代MBR和第二阶段引导程序，UEFI固件会加载引导程序的<code>.efi</code>文件，再由引导程序加载操作系统。</p>          </div><p>至此，操作系统被顺利加载到内存并接管了计算机。</p><h3 id="操作系统初始化">操作系统初始化</h3><p>在UNIX/类UNIX操作系统中，操作系统内核（Kernel）首先构造出第一个进程（这里称为init进程），init进程通过fork和exec操作创建若干个子进程来进行各项任务（比如用户登录、终端、桌面，等等）。</p><h3 id="操作系统基本形态">操作系统基本形态</h3><p>如下所示，操作系统的核心主要包括调度程序（这里指短程调度，即选择已被加载到内存中的进程投入运行）和中断处理程序（这里包括来自进程的系统调用和来自进程或外部设备的中断）。</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br></pre></td><td class="code"><pre><code class="hljs None">                    ┌────────────────────────────────────────────────────────────────────────┐<br>                    │                                                                        │<br>                    │  ┌────────────────────┐                 ┌─────┐  ┌─────┐  ┌─────┐      │<br>                    │  │                    │                 │     │  │     │  └─────┘      │<br>                    │  │                    │                 │     │  │     │  ┌─────┐      │<br>Service Call  ──────┼──┼──► Service Call    │                 │     │  │     │  ├─────┤      │<br>    from Process    │  │       Handler      │                 │     │  │     │  └─────┘      │<br>                    │  │                    │                 │     │  │     │  ┌─────┐      │<br>                    │  └────────────────────┘                 │     │  │     │  └─────┘      │<br>                    │                                         │     │  │     │  ┌─────┐      │<br>                    │                                         │     │  │     │  ├─────┤      │<br>                    │                                         └─────┘  └─────┘  └─────┘      │<br>                    │                                      Long-Term  Short-Term  I/O        │<br>                    │                                          Queue       Queue   Queues    │<br>                    │                                                                        │<br>                    │  ┌─────────────────────┐                 ┌────────────────────────┐    │<br>                    │  │                     │                 │                        │    │<br>                    │  │      Interrupt      │                 │                        │    │<br>  Interrupt    ─────┼──┼─►       Handler     │                 │       Scheduler        │    │<br>     from Process   │  │                     │                 │                        │    │<br>  Interrupt    ─────┼──┼─►                   │                 │          │             │    │<br>     from I/O       │  └─────────────────────┘                 └──────────┼─────────────┘    │<br>                    │                                                     │                  │<br>                    │                                                     │                  │<br>                    │                                                     │                  │<br>                    └─────────────────────────────────────────────────────┼──────────────────┘<br>                                                                          │<br>                                                                          ▼<br>                                                                      Pass Control<br>                                                                          to Process<br></code></pre></td></tr></table></figure><h3 id="操作系统如何保护自己">操作系统如何保护自己</h3><p>答案是利用硬件提供的保护机制：</p><ul><li>CPU区分内核态和用户态，两种状态下，CPU能执行的指令集有所区别（禁止用户态执行可能威胁到操作系统的指令）</li><li>主存保护机制，使程序只能访问它有权访问的主存空间</li></ul><h2 id="操作系统分类">操作系统分类</h2><ul><li>批处理操作系统<ul><li>Batch Operating System，批量化处理作业</li><li>特点：<ul><li>用户脱机工作，将任务（作业）批量交给操作系统之后无需持续关注运行情况，操作系统将自动安排这些任务的输入和执行</li><li>成批处理作业（作业成批进入系统，全部完成后成批从系统输出结果）</li><li>多道程序运行（早期为单道）</li><li>作业周转时间长（一批作业在全部完成后才会被输出）</li></ul></li></ul></li><li>分时操作系统<ul><li>Time Sharing OperatingSystem，允许多个联机用户同时使用一台计算机系统进行计算的操作系统称分时操作系统。</li><li>特点<ul><li>同时性，多个用户同时</li><li>独立性，每个用户相对独立</li><li>及时性，快速响应用户请求</li><li>交互性，用户联机工作（这里指用户与作业的交互）</li></ul></li></ul></li><li>实时操作系统<ul><li>必须在一个事先定义好的时间限制内，对外部或内部的事件进行响应和处理的操作系统</li><li>按照满足条件的不同分为软实时系统和硬实时系统</li><li>例如信息查询、过程控制系统</li></ul></li></ul><h2 id="操作系统提供的服务和接口">操作系统提供的服务和接口</h2><ul><li>从完成功能的角度看，包括如下基本服务<ul><li>创建程序</li><li>执行程序</li><li>数据的输入输出</li><li>信息的存取</li><li>通信服务</li><li>错误检测和处理</li></ul></li><li>从提高系统效率角度看，增加如下服务<ul><li>资源分配</li><li>统计</li><li>保护</li></ul></li><li>操作系统通过提供接口向上层提供服务：<ul><li>用户接口（User Interface）<ul><li>命令行用户界面（Command Line User Interface, CLI），如Shell程序</li><li>图形用户界面（Graphic User Interface, GUI），如Windows用户界面</li></ul></li><li>程序接口（API，Application Interface），系统调用（System Call）<ul><li>API函数库（以API函数的形式提供系统调用，但API函数并不都进行系统调用）</li></ul></li></ul></li></ul><h2 id="操作系统的基本元素">操作系统的基本元素</h2><ul><li>内核，提供支持系统运行的基本功能和基本操作<ul><li>微内核</li><li>宏内核</li></ul></li><li>进程，资源分配的最小单位，CPU调度的单位</li><li>线程，CPU调度的最小单位</li></ul>]]></content>
    
    
    <categories>
      
      <category>操作系统</category>
      
    </categories>
    
    
    <tags>
      
      <tag>OS</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>常见排序算法及其时间复杂度</title>
    <link href="/sort-alg/"/>
    <url>/sort-alg/</url>
    
    <content type="html"><![CDATA[<h1 id="蛮力排序">蛮力排序</h1><p>这类算法通常原理简单，易于实现，但代价往往较高，有较大的提升空间。</p><h2 id="选择排序算法">选择排序算法</h2><p>算法总是在未排序的部分中寻找最大元素，之后将最大元素与未排序部分的末尾元素交换，最后扩大已排序部分。总而言之，该算法使已排序部分从末尾逐渐向前增长，直至排序完成。</p><p>伪代码如下，它将按照从小到大的顺序对A进行排序：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs python"><span class="hljs-keyword">def</span> <span class="hljs-title function_">selection_sort</span>(<span class="hljs-params">A: <span class="hljs-built_in">list</span></span>):<br>    <span class="hljs-keyword">for</span> i <span class="hljs-keyword">in</span> reverse(<span class="hljs-built_in">range</span>(<span class="hljs-built_in">len</span>(A))): <span class="hljs-comment"># i标识了当前未排序部分的末尾位置，因此i是逐步减小的</span><br>        index_max = get_max(A, <span class="hljs-number">0</span>, i) <span class="hljs-comment"># 取得未排序部分的最大元素</span><br>        swap(A[index_max], A[i]) <span class="hljs-comment"># 将未排序部分的最大元素放到末尾，从而扩大了已排序部分</span><br></code></pre></td></tr></table></figure><p>考虑到寻找最大元素的时间复杂度为<spanclass="math inline">\(O(n)\)</span>，而寻找最大元素的过程将进行<spanclass="math inline">\(n\)</span>次，因此总时间复杂度为<spanclass="math inline">\(O(n^2)\)</span>。</p><p>不难看出该算法无需额外开辟其他空间，所以它的空间复杂度为<spanclass="math inline">\(O(1)\)</span>，我们称这些空间复杂度为<spanclass="math inline">\(O(1)\)</span>的排序算法为原地排序算法。</p><h2 id="插入排序算法">插入排序算法</h2><p>这种算法可以利用到输入元素可能存在的有序性。算法总是从未排序部分取出一个元素，然后插入到已排序部分中。如果输入的元素已经具有一定有序性，那么操作次数将大大减少。</p><p>伪代码如下，它将按照从小到大的顺序对A进行排序：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><code class="hljs python"><span class="hljs-keyword">def</span> <span class="hljs-title function_">insertion_sort</span>(<span class="hljs-params">A: <span class="hljs-built_in">list</span></span>):<br>    <span class="hljs-keyword">for</span> i <span class="hljs-keyword">in</span> <span class="hljs-built_in">range</span>(<span class="hljs-number">1</span>, <span class="hljs-built_in">len</span>(A)): <span class="hljs-comment"># 开始时，将第一个元素视为已排序部分</span><br>        temp = A[i]<br>        j = i-<span class="hljs-number">1</span><br>        <span class="hljs-keyword">while</span> j&gt;=<span class="hljs-number">0</span> <span class="hljs-keyword">and</span> A[j]&gt;A[i]: <span class="hljs-comment"># 寻找合适的插入位置</span><br>            A[j+<span class="hljs-number">1</span>] = A[j] <span class="hljs-comment"># 为待插入元素腾位置</span><br>            j -= <span class="hljs-number">1</span><br>        A[j+<span class="hljs-number">1</span>] = temp<br></code></pre></td></tr></table></figure><p>可以看出，在输入元素相对有序时，代码中用于寻找插入位置的while循环部分将会减少执行次数。在输入元素完全有序（指输入与算法运行结果一致）时，用于寻找插入位置的while循环部分不会被执行，在此时，算法的时间复杂度为<spanclass="math inline">\(O(n)\)</span>。但是，在输入元素顺序与算法运行结果完全相反时，用于寻找插入位置的while循环部分总会执行j次，在这种情况下，算法的时间复杂度为<spanclass="math inline">\(O(n^2)\)</span>。</p><p>算法的平均时间复杂度为<spanclass="math inline">\(O(n^2)\)</span>。</p><h1 id="分治排序">分治排序</h1><p>分治策略的关键是对子问题的划分和对子问题解的合并。通常，根据这两个步骤的难易程度可以把分治算法分成“难分易合型”和“易分难合型”。通过分治，可以将排序的时间复杂度从<spanclass="math inline">\(O(n^2)\)</span>改进到<spanclass="math inline">\(O(nlogn)\)</span>，<spanclass="math inline">\(O(nlogn)\)</span>是基于比较的排序算法的最优时间复杂度。</p><h2 id="快速排序算法">快速排序算法</h2><p>算法首先选取一个基准元素（pivot），然后把比它小的元素放在它的左边，把比它大的元素放在它的右边，这样我们就得到了三个部分：小于pivot的元素，pivot，大于pivot的元素，此时pivot显然已经处于正确的位置，只需要对小于和大于pivot的元素递归地排序即可完成排序。</p><p>把小于pivot的元素，pivot和大于pivot的元素合起来是容易的（不需要其他操作），而把元素划分为小于pivot，pivot和大于pivot这三部分的操作却是复杂的，所以我们称这个算法是难分易合的算法。</p><p>伪代码如下，它将按照从小到大的顺序对A进行排序：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><code class="hljs python"><span class="hljs-keyword">def</span> <span class="hljs-title function_">partition</span>(<span class="hljs-params">A: <span class="hljs-built_in">list</span>, p, r</span>):<br>    pivot = A[r] <span class="hljs-comment"># 选择pivot，这里选择末尾元素作为pivot，也可以选择其他元素</span><br>    i = p-<span class="hljs-number">1</span> <span class="hljs-comment"># 标识小于pivot的部分，开始时没有元素小于pivot，所以是p-1</span><br>    <span class="hljs-keyword">for</span> j <span class="hljs-keyword">in</span> <span class="hljs-built_in">range</span>(p, r):<br>        <span class="hljs-keyword">if</span> A[j]&lt;pivot:<br>            i += <span class="hljs-number">1</span> <span class="hljs-comment"># &quot;开辟&quot;空间存放新的小于pivot的元素</span><br>            swap(A[j], A[i])<br>    <span class="hljs-comment"># 现在，A中从p到i存放着小于pivot的元素，而从i+1到r-1存放着大于pivot的元素，A[r]存放着pivot</span><br>    swap(A[i+<span class="hljs-number">1</span>], A[r]) <span class="hljs-comment"># 把pivot放到中间</span><br>    <span class="hljs-keyword">return</span> i+<span class="hljs-number">1</span> <span class="hljs-comment"># 返回pivot的位置</span><br><br><span class="hljs-keyword">def</span> <span class="hljs-title function_">quick_sort</span>(<span class="hljs-params">A: <span class="hljs-built_in">list</span>, p, r</span>):<br>    <span class="hljs-keyword">if</span> p&lt;r:<br>        pivot_idx = partition(A, p, r) <span class="hljs-comment"># 划分</span><br>        quick_sort(A, p, pivot_idx-<span class="hljs-number">1</span>) <span class="hljs-comment"># 对左半部分排序</span><br>        quick_sort(A, pivot_idx+<span class="hljs-number">1</span>, r) <span class="hljs-comment"># 对右半部分排序</span><br></code></pre></td></tr></table></figure><p>在分析时间复杂度时，假定每次划分是均匀的（把输入的数据平均分成两半），而划分的过程显然是<spanclass="math inline">\(\Theta(n)\)</span>的，那么可以得出时间复杂度的递推式<spanclass="math inline">\(T(n)=2T(n/2)+\Theta(n)\)</span>。根据MasterTheorem，<span class="math inline">\(E=log_22=1\)</span>，因此<spanclass="math inline">\(\Theta(n)\in\Theta(n^E)\)</span>，算法时间复杂度为<spanclass="math inline">\(\Theta(nlogn)\)</span>。</p><h2 id="合并排序归并排序">合并排序（归并排序）</h2><p>算法的整体思想是将所给的输入序列分成两半，然后对这两半递归地进行排序，之后合并两个已经有序的序列。这里对序列的划分显然是容易的（分成两半即可），而对两个有序序列的合并却是相对困难的，因此我们称这个算法是易分难合的算法。</p><p>在合并两个有序序列（这里指从小到大排列）时，我们总是对比两个序列的第一个元素，将其中较小的元素取出并放进最终的结果序列中，重复这个过程直到两个有序序列都为空，就完成了合并。</p><p>伪代码如下，它将按照从小到大的顺序对A进行排序：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><code class="hljs python"><span class="hljs-keyword">def</span> <span class="hljs-title function_">merge</span>(<span class="hljs-params">A: <span class="hljs-built_in">list</span>, p, q, r</span>):<br>    left_a = A[p:q+<span class="hljs-number">1</span>]<br>    right_a = A[q:r+<span class="hljs-number">1</span>] <span class="hljs-comment"># 取出两个有序的子序列</span><br>    left_a.append(inf)<br>    right_a.append(inf) <span class="hljs-comment"># 为了方便接下来的合并</span><br>    left = <span class="hljs-number">0</span><br>    right = <span class="hljs-number">0</span><br>    <span class="hljs-keyword">for</span> i <span class="hljs-keyword">in</span> <span class="hljs-built_in">range</span>(p, r+<span class="hljs-number">1</span>):<br>        <span class="hljs-keyword">if</span> left_a[left] &lt; right_a[right]:<br>            A[i] = left_a[left]<br>            left += <span class="hljs-number">1</span><br>        <span class="hljs-keyword">else</span>:<br>            A[i] = right_a[right]<br>            right += <span class="hljs-number">1</span><br>  <br><span class="hljs-keyword">def</span> <span class="hljs-title function_">merge_sort</span>(<span class="hljs-params">A: <span class="hljs-built_in">list</span>, p, r</span>):<br>    <span class="hljs-keyword">if</span> p&lt;r:<br>        q = (p+r)/<span class="hljs-number">2</span> <span class="hljs-comment"># 拆分</span><br>        merge_sort(A, p, q) <span class="hljs-comment"># 排序</span><br>        merge_sort(A, q+<span class="hljs-number">1</span>, r) <span class="hljs-comment"># 排序</span><br>        merge(A, p, q, r) <span class="hljs-comment"># 合并</span><br></code></pre></td></tr></table></figure><p>不难看出，合并（merge）部分的时间复杂度为<spanclass="math inline">\(\Theta(n)\)</span>，则可以写出归并排序时间复杂度的递推式<spanclass="math inline">\(T(n)=2T(n/2)+\Theta(n)\)</span>。根据MasterTheorem，<span class="math inline">\(E=log_22=1\)</span>，因此<spanclass="math inline">\(\Theta(n)\in\Theta(n^E)\)</span>，算法时间复杂度为<spanclass="math inline">\(\Theta(nlogn)\)</span>。</p>]]></content>
    
    
    <categories>
      
      <category>算法设计与分析</category>
      
    </categories>
    
    
    <tags>
      
      <tag>算法</tag>
      
      <tag>选择排序</tag>
      
      <tag>插入排序</tag>
      
      <tag>快速排序</tag>
      
      <tag>归并排序</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>Hello World</title>
    <link href="/hello-world/"/>
    <url>/hello-world/</url>
    
    <content type="html"><![CDATA[<center>Hello, world!</center>]]></content>
    
    
    <categories>
      
      <category>杂项</category>
      
    </categories>
    
    
    <tags>
      
      <tag>hello, world</tag>
      
    </tags>
    
  </entry>
  
  
  
  
</search>
