<?xml version="1.0" encoding="utf-8"?>
<search>
  
  
  
  <entry>
    <title>操作系统 处理器管理</title>
    <link href="/os-schedule/"/>
    <url>/os-schedule/</url>
    
    <content type="html"><![CDATA[<h1 id="处理器管理">处理器管理</h1><p>处理器管理是操作系统的中药组成部分之一，负责<strong>管理</strong>、<strong>调度</strong>和<strong>分派</strong>处理器资源以及<strong>控制程序的执行</strong>。处理器管理主要涉及两部分的内容：<strong>处理器资源的分配</strong>和<strong>运行的程序（进程）调度</strong>。</p><h1 id="处理器基础知识">处理器基础知识</h1><ul><li><p>处理器主要由控制器、运算器、寄存器、中断装置以及高速缓存（Cache）等组成</p></li><li><p>处理器的寄存器包括通用寄存器、数据寄存器、地址寄存器和控制寄存器等多个寄存器</p></li><li><p>机器指令（简称指令）是指示计算机执行某些操作的命令，一台计算机所有指令的集合称为<strong>指令集</strong>。</p><ul><li>按照指令复杂程度和指令数量可以将计算机分为<strong>复杂指令集计算机（ComplexInstruction SetComputer，CISC）</strong>和<strong>精简指令集计算机（Reduced InstructionSet Computer，RISC）</strong>两种</li><li>指令按照使用者可以分为特权指令（仅供操作系统内核使用的指令）和非特权指令两种</li></ul></li><li><p>为了防止普通用户使用特权指令，处理器需要区分当前运行的代码属于操作系统内核还是属于普通程序，所以处理器具有不同的状态，简单来说分为<strong>管理状态</strong>（也称特权状态、系统状态、特态、管态）和<strong>用户状态</strong>（也称目标状态、用户模式、常态、目态）两种。管理状态时CPU能够执行指令集支持的所有指令，而在用户状态时CPU只能执行非特权指令。</p><ul><li>处理器状态的转换通常通过中断（包括外部设备中断、应用程序的系统调用以及程序运行过程中发生的错误等）来完成</li></ul></li><li><p>程序状态字（Program StatusWord，PSW）用于存储不同程序的处理器工作状态，每个处理器均有一组与程序执行相关的寄存器，这组寄存器就是当前该处理器上所运行程序的程序状态字。程序状态字通常包括程序的基本状态（例如下一条指令地址、状态位、条件码等），中断码和中断屏蔽位。</p><div class="note note-info">            <p>借助程序状态字以及其他信息，操作系统能够记录当前并发运行的多个程序的状态，从而能够在这些程序之间无缝切换</p>          </div></li></ul><h1 id="中断技术">中断技术</h1><p>中断是用来向CPU报告某设备已完成某项操作的手段，它是并发程序的基础。当中断到来时，CPU将会暂停正在运行的程序，转而执行该中断的相关处理程序。中断的处理需要由<strong>硬件</strong>（中断装置，用于监测中断并在中断到来时保护现场、跳转到中断处理程序）和<strong>软件</strong>（中断处理程序）相互配合完成。</p><p>中断可以按照性质分为以下两种：</p><ul><li>强迫性中断，例如发生机器故障、程序运行发生错误、外部设备中断等</li><li>自愿性中断，例如程序主动使用系统调用</li></ul><p>中断可以按照中断信号的来源分为以下两种：</p><ul><li>外中断（中断），中断信号来自外部设备，例如时钟中断（由定时器发出）、输入输出设备中断等<ul><li>外中断与现行指令无关，通常可以被屏蔽、可以嵌套，只有在两条指令之间才能响应中断</li></ul></li><li>内中断（异常），中断信号来自机器自身，例如非法指令、缺页错误、算术操作溢出、校验错等<ul><li>内中断由现行指令引发，可以在一个指令周期被处理，通常不可屏蔽（不处理该中断程序无法继续运行）、不可嵌套。可以细分为<strong>出错</strong>（例如缺页错误，处理完成后回到出错指令处执行）和<strong>陷入</strong>（例如系统调用，处理完成后执行陷入指令的下一条指令）</li></ul></li></ul><div class="note note-info">            <p>硬件如何找到中断处理程序——通过中断向量表（Interrupt VectorTable，IVT）</p>          </div><h2 id="中断事件处理的一般过程">中断事件处理的一般过程</h2><ul><li>Step 1：发现中断源（由硬件完成）</li><li>Step 2：初步保护现场（由硬件完成）</li><li>Step 3：转到中断处理程序（软件）执行<ul><li>Step 3.1：进一步保护现场</li><li>Step 3.2：执行中断处理相关代码</li><li>Step 3.3：恢复部分现场（由软件保护的现场）</li></ul></li><li>Step 4：恢复现场（硬件完成，恢复由硬件保护的现场）</li></ul><h2 id="中断的优先级">中断的优先级</h2><p>在同时有多个中断发生时，中断装置需要按照一定的顺序对其做出响应，这个顺序由优先级决定。优先级通常按照对计算机影响的严重程度设定，在处理高优先级的中断时，可以屏蔽低优先级的中断。</p><p>在中断处理过程中，如果又产生了新的中断，有如下几种不同的处理策略：</p><ul><li>串行处理<ul><li>在处理中断时不管其他中断，中断按照串行顺序逐个被处理</li><li>可以通过关中断实现</li></ul></li><li>嵌套处理<ul><li>先暂停当前的中断处理过程，转而处理更高优先级的中断</li></ul></li><li>即时处理<ul><li>主要针对中断处理程序执行过程中发生的程序性中断，如果不处理，中断处理程序无法继续运行</li></ul></li></ul><h2 id="信号机制">信号机制</h2><p>一种模拟硬件中断的进程间简单通信机制（软件中断），例如：Ctrl+C结束程序运行是由内核向进程发送了SIGINT信号。</p><ul><li>内核向进程（进程发生异常，内核向其通知）</li><li>进程向进程（进程间通信，发送某个事件）</li></ul><div class="note note-info">            <center><strong>POSIX定义的信号类型</strong></center><p><a href="https://zh.wikipedia.org/wiki/SIGABRT">SIGABRT</a> · <ahref="https://zh.wikipedia.org/wiki/SIGALRM">SIGALRM</a> · <ahref="https://zh.wikipedia.org/wiki/SIGFPE">SIGFPE</a> · <ahref="https://zh.wikipedia.org/wiki/SIGHUP">SIGHUP</a> · <ahref="https://zh.wikipedia.org/wiki/SIGILL">SIGILL</a> · <ahref="https://zh.wikipedia.org/wiki/SIGINT_(POSIX)">SIGINT</a> · <ahref="https://zh.wikipedia.org/wiki/SIGKILL">SIGKILL</a> · <ahref="https://zh.wikipedia.org/wiki/SIGPIPE">SIGPIPE</a> · <ahref="https://zh.wikipedia.org/wiki/SIGQUIT">SIGQUIT</a> · <ahref="https://zh.wikipedia.org/wiki/記憶體區段錯誤">SIGSEGV</a> · <ahref="https://zh.wikipedia.org/wiki/SIGTERM">SIGTERM</a> · <ahref="https://zh.wikipedia.org/wiki/SIGUSR1和SIGUSR2">SIGUSR1</a> · <ahref="https://zh.wikipedia.org/wiki/SIGUSR1和SIGUSR2">SIGUSR2</a> · <ahref="https://zh.wikipedia.org/wiki/子进程">SIGCHLD</a> · <ahref="https://zh.wikipedia.org/wiki/SIGCONT">SIGCONT</a> · <ahref="https://zh.wikipedia.org/w/index.php?title=SIGSTOP&amp;action=edit&amp;redlink=1">SIGSTOP</a>· <ahref="https://zh.wikipedia.org/w/index.php?title=SIGTSTP&amp;action=edit&amp;redlink=1">SIGTSTP</a>· <ahref="https://zh.wikipedia.org/w/index.php?title=SIGTTIN&amp;action=edit&amp;redlink=1">SIGTTIN</a>· <ahref="https://zh.wikipedia.org/w/index.php?title=SIGTTOU&amp;action=edit&amp;redlink=1">SIGTTOU</a>· <a href="https://zh.wikipedia.org/wiki/总线错误">SIGBUS</a> · <ahref="https://zh.wikipedia.org/w/index.php?title=SIGPOLL&amp;action=edit&amp;redlink=1">SIGPOLL</a>· <ahref="https://zh.wikipedia.org/w/index.php?title=SIGPROF&amp;action=edit&amp;redlink=1">SIGPROF</a>· <a href="https://zh.wikipedia.org/wiki/SIGSYS">SIGSYS</a> · <ahref="https://zh.wikipedia.org/w/index.php?title=SIGTRAP&amp;action=edit&amp;redlink=1">SIGTRAP</a>· <ahref="https://zh.wikipedia.org/w/index.php?title=SIGURG&amp;action=edit&amp;redlink=1">SIGURG</a>· <ahref="https://zh.wikipedia.org/w/index.php?title=SIGVTALRM&amp;action=edit&amp;redlink=1">SIGVTALRM</a>· <ahref="https://zh.wikipedia.org/w/index.php?title=SIGXCPU&amp;action=edit&amp;redlink=1">SIGXCPU</a><ahref="https://zh.wikipedia.org/w/index.php?title=SIGXFSZ&amp;action=edit&amp;redlink=1">SIGXFSZ</a></p>          </div><h1 id="进程">进程</h1><p>进程（Process）是一个<strong>可并发执行</strong>的具有独立功能的<strong>程序</strong>关于某个<strong>数据集合</strong>的一次<strong>执行过程</strong>，也是操作系统进行<strong>资源分配和保护的基本单位</strong>。</p><p>从理论角度来看，进程是对正在运行的程序活动规律的抽象。从实现角度来看，进程是刻画程序运行状态和系统动态变化的一种数据结构。</p><p>通过进程可以发挥系统的并发性，提高资源利用率，换言之，进程是并发程序设计的工具。此外，进程能够解决同一段代码的共享性的问题，它能够正确描述程序的执行状态（标识程序的多次运行）。</p><h2 id="进程的状态和转换">进程的状态和转换</h2><p>进程的五态模型如下所示（忽略这糟糕的排版），</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><code class="hljs None">┌───────────────┐<br>│               │<br>│     新建态     │<br>│               │<br>└──────┬────────┘<br>       │<br>       │ 分配资源、加载程序<br>       │<br>       ▼<br>┌───────────────┐ 调度程序选中   ┌────────────────┐         ┌─────────────────┐<br>│               ├─────────────►│                │ 运行完成 │                 │<br>│     就绪态     │              │     运行态      ├────────►│     终止态       │<br>│               │◄─────────────┤                │         │                 │<br>└───────────────┘     落选      └───────┬────────┘         └─────────────────┘<br>       ▲                               │<br>       │                               │出现等待事件（例如Sleep）<br>       │                               │<br>       │                               ▼<br>       │                       ┌─────────────────┐<br>       │                       │                 │<br>       └───────────────────────┤      等待态      │<br>        等待结束                │                 │<br>                               └─────────────────┘<br></code></pre></td></tr></table></figure><p>进程挂起是指将进程对换到外部存储器（例如：磁盘）上，释放器占有的系统资源（例如：内存），排除在进程调度之外。这样做的目的是提高系统资源利用率，减轻系统负载或者用于调试程序。</p><p>具有挂起状态的状态转换模型如下所示（忽略这糟糕的排版），</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><code class="hljs None">┌───────────────┐        ┌────────────────┐<br>│               │  提交   │                │            等待事件结束<br>│     新建态     ├───────►│    挂起就绪态    │◄──────────────────────────────────────────┐<br>│               │        │                │                                           │<br>└──────┬────────┘        └────┬───────────┘                                           │<br>       │          解除挂起      │  ▲    ▲                                               │<br>  提交  │  ┌───────────────────┘  │    │                                               │<br>       │  │                      │    │                                               │<br>       │  │  ┌───────────────────┘    │ 挂起                                           │<br>       ▼  ▼  │    挂起                 │                                               │<br>┌────────────┴──┐              ┌──────┴─────────┐         ┌─────────────────┐         │<br>│               ├─────────────►│                │         │                 │         │<br>│    就绪态      │              │     运行态      ├────────►│      终止态      │         │<br>│               │◄─────────────┤                │         │                 │         │<br>└───────────────┘              └───────┬────────┘         └─────────────────┘         │<br>       ▲                               │                                              │<br>       │                               │ 等待事件                                      │<br>       │                               │                                              │<br>       │                               ▼                                              │<br>       │                       ┌─────────────────┐  挂起     ┌───────────────┐         │<br>       │                       │                 ├────────► │               │         │<br>       └───────────────────────┤      等待态      │          │    挂起等待态   ├─────────┘<br>           等待事件结束          │                 │◄─────────┤               │<br>                               └─────────────────┘ 解除挂起  └───────────────┘<br></code></pre></td></tr></table></figure><h2 id="进程的结构">进程的结构</h2><p>进程的内存映像包括进程控制块（Process ControlBlock，PCB）、核心堆栈（供内核态使用）、用户堆栈（供用户态使用）以及用户私有地址空间（代码段、数据段等）和共享地址空间。</p><p>进程的物理实体和支持进程运行的环境合称为进程上下文，因此进程的上下文切换就是进程的切换。它包括：</p><ul><li>用户级上下文<ul><li>程序段、数据段、用户堆栈、共享存储区等</li></ul></li><li>寄存器上下文<ul><li>程序状态字（PSW）寄存器、栈指针寄存器、通用寄存器等</li></ul></li><li>系统级上下文<ul><li>进程控制块、主存管理信息（如页表、段表等）、核心堆栈</li></ul></li></ul><p>每个进程有且仅有一个<strong>进程控制块</strong>，它存储着进程标识信息、进程现场信息（通用寄存器、PSW寄存器等寄存器的值）以及进程控制信息（调度信息、通信信息、资源信息等）。</p><p>一个进程控制块刻画了一个进程的运行状态，而进程控制块的集合则刻画了一个操作系统当前的运行状态。进程控制块的使用和修改只能由操作系统内核来完成。</p><p>进程队列将同一状态（例如：等待队列、就绪队列）的所有进程控制块链接在一起，以便于操作系统进行统一的管理和调度。</p><h2 id="进程控制">进程控制</h2><h3 id="进程创建">进程创建</h3><p>常见原语：fork，clone，……</p><ul><li>fork：用于创建子进程，创建出的进程与原进程是父子进程关系</li><li>clone：用于创建进程，创建出的进程与原进程是对等关系</li></ul><p>创建过程：</p><ul><li>申请PCB（进程控制块）</li><li>分配进程映像空间</li><li>分配资源</li><li>将进程内容装入分配空间</li><li>初始化PCB，分配唯一标识</li><li>加入就绪队列或投入运行</li><li>通知操作系统其他模块</li></ul><h3 id="进程阻塞与唤醒">进程阻塞与唤醒</h3><p>常见原语（阻塞）：wait，waitpid，sleep，……</p><p>进程阻塞过程：</p><ul><li>保存现场到PCB</li><li>修改进程状态（运行态-&gt;等待态）</li><li>将PCB加入<strong>相应的</strong>等待队列</li><li>转到进程调度程序，调度执行其他进程</li></ul><p>进程唤醒过程：</p><ul><li>从<strong>相应的</strong>等待队列中取出PCB</li><li>修改进程状态（等待态-&gt;就绪态）</li><li>将PCB加入就绪队列</li><li>转到进程调度程序，或继续执行原进程</li></ul><h3 id="进程终止">进程终止</h3><p>常见原语：exit</p><p>终止过程：</p><ul><li>根据进程标识找到对应的PCB</li><li>将该进程资源归还给父进程或操作系统</li><li>若有子进程，则终止所有子（孙）进程</li><li>将PCB移出队列，将PCB归还给PCB池</li></ul><h1 id="线程">线程</h1><p>从上面的讨论可以发现，以进程为单位的并发程序效率不高，存在着进程时空开销大（调度和进程切换时间长，空间占用大），通信代价高（需要借助操作系统），进程间并发粒度大等问题。</p><p>为了解决这些问题，将进程<strong>独立分配资源</strong>和<strong>独立分派调度</strong>这两项功能分离出来，就产生了<strong>线程</strong>（Thread）的概念。一个进程的多个线程共享同一个用户地址空间，但同时每个进程拥有自己独立的堆栈空间和指令执行序列，这样，同一进程的不同线程既可以访问相同的共享变量（存储于进程的数据空间中），又能够互不干扰地各自执行指令（拥有独立的堆栈和寄存器）。</p><p>在多线程环境下，<strong>进程</strong>是操作系统中进行保护和资源分配的基本单位，而<strong>线程</strong>是处理器调度和分配的基本单位，同一进程的所有线程共享进程获得的主存空间和资源。</p><h2 id="线程的管理与实现">线程的管理与实现</h2><p>基本的线程管理原语：</p><ul><li>thread_create 创建线程</li><li>thread_join 等待线程</li><li>thread_yield 出让（主动让出线程自身的执行机会）</li><li>thread_exit 终止线程</li></ul><p>线程的实现方式分为内核级线程，用户级线程和前两者的混合实现，如下所示，</p><p><img src="\illustration\os-schedule\线程实现.png" alt="线程的三种实现" style="zoom: 67%;" /></p><ul><li>内核级线程<ul><li>由内核管理的线程</li><li>优点<ul><li>能够在多个处理器上同时执行多个线程</li><li>某个进程中一个线程被阻塞，不会影响其他线程的运行</li></ul></li><li>缺点<ul><li>线程间切换代价高，需要涉及两次模式切换（用户态-&gt;内核态内核态-&gt;用户态）</li></ul></li></ul></li><li>用户级实现<ul><li>用户线程的建立、同步、销毁、调度完全在用户空间完成，不需要内核的帮助</li><li>优点<ul><li>线程切换不涉及模式切换，代价小</li><li>调度算法选择灵活（由进程自行调度）</li></ul></li><li>缺点<ul><li>同一进程的不同线程不能同时在多个处理器上运行</li><li>一个线程的阻塞将导致整个进程的阻塞</li><li>非抢占式调度</li></ul></li><li>改进机制<ul><li>upcall机制</li><li>非阻塞系统调用，增加select系统调用</li></ul></li></ul></li><li>混合实现<ul><li>例如将若干个用户线程绑定到一个内核线程上</li><li>设计得当，可结合前两者的优点</li><li>设计不当，将产生更差的效果</li></ul></li></ul><div class="note note-info">            <p>内核提供一组虚拟处理器(LWP)给应用程序，应用程序可调度用户线程到一个可用的虚拟处理器上。内核需要告知用户该线程的运行状态，这个过程被称为<strong>upcall</strong>。详见<ahref="https://blog.csdn.net/weixin_42250655/article/details/103571820">https://blog.csdn.net/weixin_42250655/article/details/103571820</a></p>          </div><h2 id="并发多线程程序设计的优点">并发多线程程序设计的优点</h2><ul><li>易于实现多个活动间的通信（共享变量）</li><li>更低的管理开销</li><li>I/O密集型应用能获得更好的性能</li><li>能更好地利用多（核）处理器，加快程序执行</li></ul><h1 id="处理器调度">处理器调度</h1><p>处理器调度的主要内容是：</p><ul><li>挑选作业进入内存</li><li>在进程（线程）之间分配处理器时间</li></ul><p>处理器调度可以分为：</p><ul><li>高级调度（作业调度、长程调度），为提交的作业分配资源，决定作业是否进入主存（即决定提交的作业置为就绪态还是挂起就绪态）</li><li>中级调度（平衡负载调度、中程调度），决定哪些作业（进程）留在主存中，控制外存和内存的对换（例如，挂起-&gt;解除挂起）</li><li>低级调度（进程/线程调度、短程调度），决定进程/线程是否占用处理器执行（例如，就绪-&gt;运行）</li></ul><h2 id="高级调度">高级调度</h2><p>在多道批处理系统中，高级调度的工作：</p><ul><li>后备作业-&gt;进程</li><li>作业准备-&gt;启动-&gt;善后工作</li></ul><p>在分时系统中，高级调度的工作：</p><ul><li>是否接受一个终端用户的连接</li><li>交互作业能否被接纳，并创建进程</li></ul><h2 id="中级调度">中级调度</h2><ul><li>控制主存储器中容纳的进程数</li><li>保证在合理数目的进程，竞争处理器和相关资源</li></ul><div class="note note-info">            <p>挂起的进程不参与低级调度</p>          </div><h2 id="低级调度">低级调度</h2><p>存在两种调度方式：</p><ul><li>抢占方式（剥夺方式）<ul><li>优先级抢占</li><li>限时抢占</li></ul></li><li>非抢占方式（非剥夺方式）</li></ul><p>抢占方式调度的开销通常大于非抢占方式，但是可以避免一个进程或线程长时间独占处理器。</p><h2 id="调度算法">调度算法</h2><p>任何层次的处理器调度均由操作系统相应的调度程序实施，调度程序所使用的算法，被称为调度算法。</p><h3 id="调度算法考虑的主要因素">调度算法考虑的主要因素</h3><ul><li>资源利用率 -&gt; 不要让CPU空转<ul><li>CPU有效工作时间/CPU总运行时间</li></ul></li><li>响应时间<ul><li>从作业提交到收到回应的时间</li></ul></li><li>周转时间<ul><li>作业提交到作业完成的时间</li><li>平均周转时间、平均带权周转时间</li></ul></li><li>吞吐率<ul><li>单位时间处理的作业数</li></ul></li><li>公平性<ul><li>确保每个进程获得合理的资源份额</li></ul></li></ul><h3 id="典型高级调度算法">典型高级调度算法</h3><h4 id="先来先服务-first-come-first-served-fcfs">先来先服务 First-ComeFirst-Served FCFS</h4><p>按照作业进入系统的作业后备队列的先后次序挑选作业，先进入系统的作业优先被选择</p><ul><li>优点<ul><li>实现简单</li></ul></li><li>缺点<ul><li>不利于短作业而优待长作业（先到达的长作业周转时间短于后到达的短作业）</li><li>效率低</li></ul></li></ul><h4 id="最短作业优先算法-sjf">最短作业优先算法 SJF</h4><p>以进入系统的作业所要求的CPU时间长短为标准，总是挑选时间最短的作业投入运行</p><ul><li>优点<ul><li>实现简单</li><li>效率相对较高</li></ul></li><li>缺点<ul><li>在实际系统中，往往难以预测作业的CPU时间</li><li>长作业等待时间可能会过长（持续有短作业进入系统，长作业将难以得到服务）</li></ul></li></ul><h4 id="最短剩余时间优先-srtf">最短剩余时间优先 SRTF</h4><p>每次调度时，总选择预测剩余运行时间最短的作业优先运行</p><ul><li>优点<ul><li>效率相对较高</li></ul></li><li>缺点<ul><li>调度频繁</li><li>剩余运行时间难以预测</li><li>长作业等待时间可能过长</li></ul></li></ul><h4 id="响应比最高优先算法-hrrf">响应比最高优先算法 HRRF</h4><p>响应比=作业周转时间（响应时间）/作业预计计算时间=(作业预计计算时间+作业等待时间)/作业预计计算时间</p><p>总是选择响应比最高的作业投入运行，从而防止了作业等待时间过长的“饥饿”现象发生</p><h3 id="典型低级调度算法">典型低级调度算法</h3><h4 id="先来先服务-first-come-first-served-fcfs-1">先来先服务 First-ComeFirst-Served FCFS</h4><p>非抢占式调度方式，可以使用就绪队列实现先进先出，但是效率不高，不利于I/O频繁操作的进程（一发生I/O就被移至就绪队列队尾，从而需要等待较长时间才能再次执行）</p><h4 id="时间片轮转-round-robin">时间片轮转 Round-Robin</h4><p>抢占式调度方式，基本原理是利用时钟中断轮流执行各进程</p><ul><li>分类<ul><li>基本时间片轮转法，各进程时间片相同</li><li>动态时间片轮转法，各进程时间片不同</li></ul></li><li>时间片选取<ul><li>时间片过长-&gt;FCFS</li><li>时间片过短-&gt;调度频繁，效率不高</li></ul></li></ul><h4 id="优先数调度-priority-scheduling">优先数调度 PriorityScheduling</h4><p>抢占（高优先级进程抢占低优先级进程）和非抢占式（低优先级进程无法抢占高优先级进程）调度方式。总是取优先级最大的进程执行</p><ul><li>分类<ul><li>静态优先数</li><li>动态优先数<ul><li>基本原则：一个进程连续占用处理器的时间越长，则其优先数越小；一个进程等待处理器的时间越长，则其优先数越大</li><li>计算优先数需要占用较多的CPU时间，为降低调度开销，应选择合适的时机和合适的计算对象</li><li>具体细节可以参考早期UNIX调度算法的实现</li></ul></li></ul></li></ul><h4 id="最短进程优先-shortest-process-first">最短进程优先 ShortestProcess First</h4><p>下次持续执行时间短的进程优先。</p><ul><li>下次持续执行时间的估算使用<strong>老化（aging）算法</strong>，即<spanclass="math inline">\(aT_0+(1-a)T_1\)</span>，其中<spanclass="math inline">\(a\)</span>为老化系数。</li></ul><h4 id="多级反馈队列调度-multiple-queues">多级反馈队列调度 MultipleQueues</h4><p>基本思想：将就绪队列分为多级队列，较高的队列分配时间片较短，但是具有较高的优先权占有处理器；较低的队列分配时间片较长，但是占有处理器的优先权较低。同一队列的进程按照先来先服务的原则进行调度。进程的分级可以静态分级也可以动态分级。</p><h4 id="保证调度-guaranteed-scheduling">保证调度 GuaranteedScheduling</h4><p>基本思想：对每个进程做出性能保证，并在调度中尽力实现该保证。例如，在有n个进程时，保证每个进程获得1/n的处理器能力，那么调度时总是优先执行实际获得处理器时间与应得处理器时间差距最大的进程。</p><h4 id="彩票调度-lottery-scheduling">彩票调度 Lottery Scheduling</h4><p>基本思想：为进程发放针对系统资源的“彩票”，当调度程序选择进程时，随机选择一张“彩票”，持有该“彩票”的进程将被选择。这样，进程持有的彩票越多，它被分配系统资源的概率就越大。</p><h2 id="实时系统及其调度算法">实时系统及其调度算法</h2><p>实时系统的计算正确性不仅取决于计算的逻辑正确性，还取决于产生结果的时间。如果未满足系统的时间约束，则认为系统失效。也就是说，实时系统对响应时间具有特殊要求，在这类系统中，时间是非常关键的因素。</p><ul><li>分类<ul><li>软实时系统：提供统计意义上的实时。例如，有的应用要求系统在95%的情况下都会确保在规定的时间内完成某个动作，而不一定要求100%</li><li>硬实时系统：实时性必须达到100%，例如卫星发射系统、核反应堆控制系统等</li></ul></li><li>构成<ul><li>将程序分为多个进程，每个进程负责处理相应的周期性事件</li></ul></li><li>特点<ul><li>规模小，进程切换快，处理时间短，能够管理多个高精度计时器</li></ul></li></ul><h3 id="可调度">可调度</h3><p>可调度是指在忽略调度本身所花费CPU时间的前提下，系统能够在各事件规定的响应时间内处理完成这些事件。</p><p>对于周期事件，可以使用下面的公式判断系统是否可调度：</p><ul><li><span class="math inline">\(C_1/P_1+C_2/P_2+...+C_m/P_m\le1\)</span>，其中<span class="math inline">\(m\)</span>为事件总数，<spanclass="math inline">\(C_i\)</span>为某个事件的处理时间，<spanclass="math inline">\(P_i\)</span>为事件发生的周期</li></ul><h3 id="典型实时调度算法">典型实时调度算法</h3><h4 id="单比率调度算法静态">单比率调度算法（静态）</h4><p>令进程的优先级与对应事件出现频率成正比，该算法理论上最优</p><h4 id="限期调度算法动态">限期调度算法（动态）</h4><p>进程的就绪队列按照对应事件的截止期限排序</p><h4 id="最少裕度调度算法动态">最少裕度调度算法（动态）</h4><p>裕度=截止时间-(就绪时间+计算时间)，该算法总是选择裕度最小的进程优先执行</p>]]></content>
    
    
    <categories>
      
      <category>操作系统</category>
      
    </categories>
    
    
    <tags>
      
      <tag>OS</tag>
      
      <tag>调度算法</tag>
      
      <tag>CPU</tag>
      
      <tag>进程</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>操作系统 概论</title>
    <link href="/os-overview/"/>
    <url>/os-overview/</url>
    
    <content type="html"><![CDATA[<h1 id="计算机系统">计算机系统</h1><p>计算机系统通常包括计算机硬件（Hardware）、操作系统（OperatingSystem）和应用程序（Application）以及用户（User）几个部分；操作系统运行在计算机硬件上，而应用程序依赖于操作系统向上层提供的一系列服务和接口运行，最后，用户使用应用程序完成自己的工作；这些部分之间的关系如下所示。</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><code class="hljs None"> ┌──────────────┐   ┌───────────────┐                 ┌──────────────┐<br> │     USER1    │   │     USER2     │    ... ...      │     USERn    │<br> └───────┬──────┘   └───────┬───────┘                 └───────┬──────┘<br>         │                  │                                 │<br>         ▼                  ▼                                 ▼<br>┌─────────────────────────────────────────────────────────────────────┐<br>│                                                                     │<br>│                             APPLICATION                             │<br>│                                                                     │<br>│         ┌────────────────────────────────────────────────┐          │<br>│         │                                                │          │<br>└─────────┤                OPERATING SYSTEM                ├──────────┘<br>          │                                                │<br>          │        ┌───────────────────────────────┐       │<br>          └────────┤                               ├───────┘<br>                   │           HARDWARE            │<br>                   │                               │<br>                   └───────────────────────────────┘<br></code></pre></td></tr></table></figure><p>可以看到，从硬件向上到应用程序，它们的覆盖范围是逐层加大的。可以这样理解：操作系统通过各种方法扩展和增强了硬件的功能（例如虚拟内存机制的使用，在应用程序层面来看扩充了实际内存的大小；又例如分时多任务机制的使用，在用户层面来看有多个程序在同时运行，但实际的处理器数量并没有这么多）；而应用程序又利用操作系统提供的各种接口和服务进一步扩展和增强了计算机的功能（例如五花八门的应用程序让用户通过计算机完成各种任务，而不仅限于计算）。</p><h1 id="操作系统">操作系统</h1><p>计算机系统是一个具有层次结构的系统，<strong>操作系统是处于硬件和应用程序中间的软件，它向上为应用程序提供简洁易用的资源抽象，屏蔽复杂的底层逻辑；向下管理种类繁多的硬件资源</strong>。</p><h2 id="功能和目标">功能和目标</h2><h3 id="功能">功能</h3><ul><li>资源管理（包括处理器管理、存储管理、设备管理、文件管理等）</li><li>控制执行（例如进程调度、进程的并发控制等）</li><li>提供接口（例如作业管理提供了向计算机输入作业的接口）</li></ul><h3 id="目标">目标</h3><ul><li>方便用户使用</li><li>提升机器能力（例如：并发控制使得单核处理器计算机也能“同时”运行多个程序）</li><li>提高运行效率（例如：并发有效利用了处理器资源）</li><li>提供开放环境（例如：操作系统提供了一个可供应用程序运行的开放环境）</li></ul><h2 id="主要特征">主要特征</h2><h3 id="并发性">并发性</h3><ul><li>并发是指两个或两个以上事件在<strong>同一时间间隔内</strong>发生。并发提高了资源利用率（一心多用），但是增加了管理复杂度（例如为了保证程序之间不相互影响而对资源进行的保护，等等）</li><li>支持并发的操作系统称之为多任务系统</li></ul><div class="note note-info">            <p>并行是指两个或两个以上事件或活动在<strong>同一时刻</strong>发生，它是并发的特例。</p>          </div><h3 id="共享性">共享性</h3><ul><li>共享性是指系统中的资源可被多个并发执行的任务（作业）所使用</li><li>两类共享方式：<ul><li>互斥访问（适用于某一时刻只能被一个任务访问的资源，例如打印机、屏幕输出等）</li><li>同时访问（适用于某一时刻可以被多个任务访问的资源，例如读取文件内容、读取传感器数据等）</li></ul></li></ul><h3 id="异步性">异步性</h3><ul><li>主要表现<ul><li>任务执行的时间、推进速度等不定（例如，每个程序执行的时间可能是不相同的）</li><li>事件发生的不可预期，如各种中断的发生（例如，我现在按了一下键盘的某个键）</li></ul></li><li>对操作系统的要求<ul><li>能够处理随机发生的各种事件</li><li>在不同的事件序列中，确保任务的正确执行（例如，程序不能因为我插了个耳机就崩溃了）</li></ul></li></ul><h3 id="虚拟性">虚拟性</h3><ul><li>虚拟性是操作系统中的一种管理技术，是指将物理上的一个实体变成逻辑上的多个对应物，或将物理上的多个实体变成逻辑上的一个对应物的技术。</li><li>例如，虚拟内存（将逻辑上的一个个内存块映射到不同的内存或磁盘空间中）</li></ul><h2 id="操作系统运行机制概览">操作系统运行机制概览</h2><h3 id="从接通电源到操作系统">从接通电源到操作系统</h3><h4 id="step-1接通电源运行bios">Step 1：接通电源，运行BIOS</h4><p>接通电源后，CPU首先会执行一条跳转指令，这条指令将会使CPU跳转BIOS代码继续执行，BIOS在进行一系列初始化和自检工作（该过程被称为POST过程）后，执行自举过程，该过程将第一阶段引导程序的代码（是主引导记录的一部分）从磁盘指定位置（磁盘的首个扇区）调入到内存中，随后跳转到第一阶段引导程序继续执行。</p><div class="note note-info">            <p>BIOS的全称是Basic Input OutputSystem，它是硬件厂商在硬件上自带的一段启动的代码，作用是进行一些硬件检查，并且跳转到引导程序bootloader。</p>          </div><div class="note note-info">            <p>引导程序，英文为Bootloader，引导在英文中为“boot”，是bootstrap的缩写，源自于短语“Pulloneself up by one'sbootstraps”，即“靠自己振作起来”。引导程序的任务是将另一段程序代码加载到内存中。</p>          </div><div class="note note-info">            <p>主引导记录，英文为Master BootRecord，简称MBR，又称主引导扇区，记录着引导程序代码和硬盘本身的相关信息以及硬盘各个分区的大小及位置信息。</p>          </div><h4 id="step-2第一阶段引导程序加载第二阶段引导程序">Step2：第一阶段引导程序加载第二阶段引导程序</h4><p>第一阶段引导程序经由BIOS加载并开始执行，而第一阶段引导程序将会把第二阶段引导程序加载到内存中，然后跳转到第二阶段引导程序。这么做的原因是第一阶段引导程序的大小受到限制（因为它存储在主引导记录中，而主引导记录仅有一个扇区大小），无法完成复杂的功能。</p><h4 id="step-3第二阶段引导程序加载操作系统">Step3：第二阶段引导程序加载操作系统</h4><p>第二阶段引导程序不再拘于一个扇区大小，因此可以完成更复杂的功能，它将会把操作系统内核（Kernel）加载到内存中，最终把计算机的控制权交给操作系统内核。常见的第二阶段引导程序有LILO、GRUB等。</p><div class="note note-info">            <p>对于UEFI系统，由EFI应用程序（即EFI系统分区中的<code>.efi</code>文件）取代MBR和第二阶段引导程序，UEFI固件会加载引导程序的<code>.efi</code>文件，再由引导程序加载操作系统。</p>          </div><p>至此，操作系统被顺利加载到内存并接管了计算机。</p><h3 id="操作系统初始化">操作系统初始化</h3><p>在UNIX/类UNIX操作系统中，操作系统内核（Kernel）首先构造出第一个进程（这里称为init进程），init进程通过fork和exec操作创建若干个子进程来进行各项任务（比如用户登录、终端、桌面，等等）。</p><h3 id="操作系统基本形态">操作系统基本形态</h3><p>如下所示，操作系统的核心主要包括调度程序（这里指短程调度，即选择已被加载到内存中的进程投入运行）和中断处理程序（这里包括来自进程的系统调用和来自进程或外部设备的中断）。</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br></pre></td><td class="code"><pre><code class="hljs None">                    ┌────────────────────────────────────────────────────────────────────────┐<br>                    │                                                                        │<br>                    │  ┌────────────────────┐                 ┌─────┐  ┌─────┐  ┌─────┐      │<br>                    │  │                    │                 │     │  │     │  └─────┘      │<br>                    │  │                    │                 │     │  │     │  ┌─────┐      │<br>Service Call  ──────┼──┼──► Service Call    │                 │     │  │     │  ├─────┤      │<br>    from Process    │  │       Handler      │                 │     │  │     │  └─────┘      │<br>                    │  │                    │                 │     │  │     │  ┌─────┐      │<br>                    │  └────────────────────┘                 │     │  │     │  └─────┘      │<br>                    │                                         │     │  │     │  ┌─────┐      │<br>                    │                                         │     │  │     │  ├─────┤      │<br>                    │                                         └─────┘  └─────┘  └─────┘      │<br>                    │                                      Long-Term  Short-Term  I/O        │<br>                    │                                          Queue       Queue   Queues    │<br>                    │                                                                        │<br>                    │  ┌─────────────────────┐                 ┌────────────────────────┐    │<br>                    │  │                     │                 │                        │    │<br>                    │  │      Interrupt      │                 │                        │    │<br>  Interrupt    ─────┼──┼─►       Handler     │                 │       Scheduler        │    │<br>     from Process   │  │                     │                 │                        │    │<br>  Interrupt    ─────┼──┼─►                   │                 │          │             │    │<br>     from I/O       │  └─────────────────────┘                 └──────────┼─────────────┘    │<br>                    │                                                     │                  │<br>                    │                                                     │                  │<br>                    │                                                     │                  │<br>                    └─────────────────────────────────────────────────────┼──────────────────┘<br>                                                                          │<br>                                                                          ▼<br>                                                                      Pass Control<br>                                                                          to Process<br></code></pre></td></tr></table></figure><h3 id="操作系统如何保护自己">操作系统如何保护自己</h3><p>答案是利用硬件提供的保护机制：</p><ul><li>CPU区分内核态和用户态，两种状态下，CPU能执行的指令集有所区别（禁止用户态执行可能威胁到操作系统的指令）</li><li>主存保护机制，使程序只能访问它有权访问的主存空间</li></ul><h2 id="操作系统分类">操作系统分类</h2><ul><li>批处理操作系统<ul><li>Batch Operating System，批量化处理作业</li><li>特点：<ul><li>用户脱机工作，将任务（作业）批量交给操作系统之后无需持续关注运行情况，操作系统将自动安排这些任务的输入和执行</li><li>成批处理作业（作业成批进入系统，全部完成后成批从系统输出结果）</li><li>多道程序运行（早期为单道）</li><li>作业周转时间长（一批作业在全部完成后才会被输出）</li></ul></li></ul></li><li>分时操作系统<ul><li>Time Sharing OperatingSystem，允许多个联机用户同时使用一台计算机系统进行计算的操作系统称分时操作系统。</li><li>特点<ul><li>同时性，多个用户同时</li><li>独立性，每个用户相对独立</li><li>及时性，快速响应用户请求</li><li>交互性，用户联机工作（这里指用户与作业的交互）</li></ul></li></ul></li><li>实时操作系统<ul><li>必须在一个事先定义好的时间限制内，对外部或内部的事件进行响应和处理的操作系统</li><li>按照满足条件的不同分为软实时系统和硬实时系统</li><li>例如信息查询、过程控制系统</li></ul></li></ul><h2 id="操作系统提供的服务和接口">操作系统提供的服务和接口</h2><ul><li>从完成功能的角度看，包括如下基本服务<ul><li>创建程序</li><li>执行程序</li><li>数据的输入输出</li><li>信息的存取</li><li>通信服务</li><li>错误检测和处理</li></ul></li><li>从提高系统效率角度看，增加如下服务<ul><li>资源分配</li><li>统计</li><li>保护</li></ul></li><li>操作系统通过提供接口向上层提供服务：<ul><li>用户接口（User Interface）<ul><li>命令行用户界面（Command Line User Interface, CLI），如Shell程序</li><li>图形用户界面（Graphic User Interface, GUI），如Windows用户界面</li></ul></li><li>程序接口（API，Application Interface），系统调用（System Call）<ul><li>API函数库（以API函数的形式提供系统调用，但API函数并不都进行系统调用）</li></ul></li></ul></li></ul><h2 id="操作系统的基本元素">操作系统的基本元素</h2><ul><li>内核，提供支持系统运行的基本功能和基本操作<ul><li>微内核</li><li>宏内核</li></ul></li><li>进程，资源分配的最小单位，CPU调度的单位</li><li>线程，CPU调度的最小单位</li></ul>]]></content>
    
    
    <categories>
      
      <category>操作系统</category>
      
    </categories>
    
    
    <tags>
      
      <tag>OS</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>常见排序算法及其时间复杂度</title>
    <link href="/sort-alg/"/>
    <url>/sort-alg/</url>
    
    <content type="html"><![CDATA[<h1 id="蛮力排序">蛮力排序</h1><p>这类算法通常原理简单，易于实现，但代价往往较高，有较大的提升空间。</p><h2 id="选择排序算法">选择排序算法</h2><p>算法总是在未排序的部分中寻找最大元素，之后将最大元素与未排序部分的末尾元素交换，最后扩大已排序部分。总而言之，该算法使已排序部分从末尾逐渐向前增长，直至排序完成。</p><p>伪代码如下，它将按照从小到大的顺序对A进行排序：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs python"><span class="hljs-keyword">def</span> <span class="hljs-title function_">selection_sort</span>(<span class="hljs-params">A: <span class="hljs-built_in">list</span></span>):<br>    <span class="hljs-keyword">for</span> i <span class="hljs-keyword">in</span> reverse(<span class="hljs-built_in">range</span>(<span class="hljs-built_in">len</span>(A))): <span class="hljs-comment"># i标识了当前未排序部分的末尾位置，因此i是逐步减小的</span><br>        index_max = get_max(A, <span class="hljs-number">0</span>, i) <span class="hljs-comment"># 取得未排序部分的最大元素</span><br>        swap(A[index_max], A[i]) <span class="hljs-comment"># 将未排序部分的最大元素放到末尾，从而扩大了已排序部分</span><br></code></pre></td></tr></table></figure><p>考虑到寻找最大元素的时间复杂度为<spanclass="math inline">\(O(n)\)</span>，而寻找最大元素的过程将进行<spanclass="math inline">\(n\)</span>次，因此总时间复杂度为<spanclass="math inline">\(O(n^2)\)</span>。</p><p>不难看出该算法无需额外开辟其他空间，所以它的空间复杂度为<spanclass="math inline">\(O(1)\)</span>，我们称这些空间复杂度为<spanclass="math inline">\(O(1)\)</span>的排序算法为原地排序算法。</p><h2 id="插入排序算法">插入排序算法</h2><p>这种算法可以利用到输入元素可能存在的有序性。算法总是从未排序部分取出一个元素，然后插入到已排序部分中。如果输入的元素已经具有一定有序性，那么操作次数将大大减少。</p><p>伪代码如下，它将按照从小到大的顺序对A进行排序：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><code class="hljs python"><span class="hljs-keyword">def</span> <span class="hljs-title function_">insertion_sort</span>(<span class="hljs-params">A: <span class="hljs-built_in">list</span></span>):<br>    <span class="hljs-keyword">for</span> i <span class="hljs-keyword">in</span> <span class="hljs-built_in">range</span>(<span class="hljs-number">1</span>, <span class="hljs-built_in">len</span>(A)): <span class="hljs-comment"># 开始时，将第一个元素视为已排序部分</span><br>        temp = A[i]<br>        j = i-<span class="hljs-number">1</span><br>        <span class="hljs-keyword">while</span> j&gt;=<span class="hljs-number">0</span> <span class="hljs-keyword">and</span> A[j]&gt;A[i]: <span class="hljs-comment"># 寻找合适的插入位置</span><br>            A[j+<span class="hljs-number">1</span>] = A[j] <span class="hljs-comment"># 为待插入元素腾位置</span><br>            j -= <span class="hljs-number">1</span><br>        A[j+<span class="hljs-number">1</span>] = temp<br></code></pre></td></tr></table></figure><p>可以看出，在输入元素相对有序时，代码中用于寻找插入位置的while循环部分将会减少执行次数。在输入元素完全有序（指输入与算法运行结果一致）时，用于寻找插入位置的while循环部分不会被执行，在此时，算法的时间复杂度为<spanclass="math inline">\(O(n)\)</span>。但是，在输入元素顺序与算法运行结果完全相反时，用于寻找插入位置的while循环部分总会执行j次，在这种情况下，算法的时间复杂度为<spanclass="math inline">\(O(n^2)\)</span>。</p><p>算法的平均时间复杂度为<spanclass="math inline">\(O(n^2)\)</span>。</p><h1 id="分治排序">分治排序</h1><p>分治策略的关键是对子问题的划分和对子问题解的合并。通常，根据这两个步骤的难易程度可以把分治算法分成“难分易合型”和“易分难合型”。通过分治，可以将排序的时间复杂度从<spanclass="math inline">\(O(n^2)\)</span>改进到<spanclass="math inline">\(O(nlogn)\)</span>，<spanclass="math inline">\(O(nlogn)\)</span>是基于比较的排序算法的最优时间复杂度。</p><h2 id="快速排序算法">快速排序算法</h2><p>算法首先选取一个基准元素（pivot），然后把比它小的元素放在它的左边，把比它大的元素放在它的右边，这样我们就得到了三个部分：小于pivot的元素，pivot，大于pivot的元素，此时pivot显然已经处于正确的位置，只需要对小于和大于pivot的元素递归地排序即可完成排序。</p><p>把小于pivot的元素，pivot和大于pivot的元素合起来是容易的（不需要其他操作），而把元素划分为小于pivot，pivot和大于pivot这三部分的操作却是复杂的，所以我们称这个算法是难分易合的算法。</p><p>伪代码如下，它将按照从小到大的顺序对A进行排序：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><code class="hljs python"><span class="hljs-keyword">def</span> <span class="hljs-title function_">partition</span>(<span class="hljs-params">A: <span class="hljs-built_in">list</span>, p, r</span>):<br>    pivot = A[r] <span class="hljs-comment"># 选择pivot，这里选择末尾元素作为pivot，也可以选择其他元素</span><br>    i = p-<span class="hljs-number">1</span> <span class="hljs-comment"># 标识小于pivot的部分，开始时没有元素小于pivot，所以是p-1</span><br>    <span class="hljs-keyword">for</span> j <span class="hljs-keyword">in</span> <span class="hljs-built_in">range</span>(p, r):<br>        <span class="hljs-keyword">if</span> A[j]&lt;pivot:<br>            i += <span class="hljs-number">1</span> <span class="hljs-comment"># &quot;开辟&quot;空间存放新的小于pivot的元素</span><br>            swap(A[j], A[i])<br>    <span class="hljs-comment"># 现在，A中从p到i存放着小于pivot的元素，而从i+1到r-1存放着大于pivot的元素，A[r]存放着pivot</span><br>    swap(A[i+<span class="hljs-number">1</span>], A[r]) <span class="hljs-comment"># 把pivot放到中间</span><br>    <span class="hljs-keyword">return</span> i+<span class="hljs-number">1</span> <span class="hljs-comment"># 返回pivot的位置</span><br><br><span class="hljs-keyword">def</span> <span class="hljs-title function_">quick_sort</span>(<span class="hljs-params">A: <span class="hljs-built_in">list</span>, p, r</span>):<br>    <span class="hljs-keyword">if</span> p&lt;r:<br>        pivot_idx = partition(A, p, r) <span class="hljs-comment"># 划分</span><br>        quick_sort(A, p, pivot_idx-<span class="hljs-number">1</span>) <span class="hljs-comment"># 对左半部分排序</span><br>        quick_sort(A, pivot_idx+<span class="hljs-number">1</span>, r) <span class="hljs-comment"># 对右半部分排序</span><br></code></pre></td></tr></table></figure><p>在分析时间复杂度时，假定每次划分是均匀的（把输入的数据平均分成两半），而划分的过程显然是<spanclass="math inline">\(\Theta(n)\)</span>的，那么可以得出时间复杂度的递推式<spanclass="math inline">\(T(n)=2T(n/2)+\Theta(n)\)</span>。根据MasterTheorem，<span class="math inline">\(E=log_22=1\)</span>，因此<spanclass="math inline">\(\Theta(n)\in\Theta(n^E)\)</span>，算法时间复杂度为<spanclass="math inline">\(\Theta(nlogn)\)</span>。</p><h2 id="合并排序归并排序">合并排序（归并排序）</h2><p>算法的整体思想是将所给的输入序列分成两半，然后对这两半递归地进行排序，之后合并两个已经有序的序列。这里对序列的划分显然是容易的（分成两半即可），而对两个有序序列的合并却是相对困难的，因此我们称这个算法是易分难合的算法。</p><p>在合并两个有序序列（这里指从小到大排列）时，我们总是对比两个序列的第一个元素，将其中较小的元素取出并放进最终的结果序列中，重复这个过程直到两个有序序列都为空，就完成了合并。</p><p>伪代码如下，它将按照从小到大的顺序对A进行排序：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><code class="hljs python"><span class="hljs-keyword">def</span> <span class="hljs-title function_">merge</span>(<span class="hljs-params">A: <span class="hljs-built_in">list</span>, p, q, r</span>):<br>    left_a = A[p:q+<span class="hljs-number">1</span>]<br>    right_a = A[q:r+<span class="hljs-number">1</span>] <span class="hljs-comment"># 取出两个有序的子序列</span><br>    left_a.append(inf)<br>    right_a.append(inf) <span class="hljs-comment"># 为了方便接下来的合并</span><br>    left = <span class="hljs-number">0</span><br>    right = <span class="hljs-number">0</span><br>    <span class="hljs-keyword">for</span> i <span class="hljs-keyword">in</span> <span class="hljs-built_in">range</span>(p, r+<span class="hljs-number">1</span>):<br>        <span class="hljs-keyword">if</span> left_a[left] &lt; right_a[right]:<br>            A[i] = left_a[left]<br>            left += <span class="hljs-number">1</span><br>        <span class="hljs-keyword">else</span>:<br>            A[i] = right_a[right]<br>            right += <span class="hljs-number">1</span><br>  <br><span class="hljs-keyword">def</span> <span class="hljs-title function_">merge_sort</span>(<span class="hljs-params">A: <span class="hljs-built_in">list</span>, p, r</span>):<br>    <span class="hljs-keyword">if</span> p&lt;r:<br>        q = (p+r)/<span class="hljs-number">2</span> <span class="hljs-comment"># 拆分</span><br>        merge_sort(A, p, q) <span class="hljs-comment"># 排序</span><br>        merge_sort(A, q+<span class="hljs-number">1</span>, r) <span class="hljs-comment"># 排序</span><br>        merge(A, p, q, r) <span class="hljs-comment"># 合并</span><br></code></pre></td></tr></table></figure><p>不难看出，合并（merge）部分的时间复杂度为<spanclass="math inline">\(\Theta(n)\)</span>，则可以写出归并排序时间复杂度的递推式<spanclass="math inline">\(T(n)=2T(n/2)+\Theta(n)\)</span>。根据MasterTheorem，<span class="math inline">\(E=log_22=1\)</span>，因此<spanclass="math inline">\(\Theta(n)\in\Theta(n^E)\)</span>，算法时间复杂度为<spanclass="math inline">\(\Theta(nlogn)\)</span>。</p>]]></content>
    
    
    <categories>
      
      <category>算法设计与分析</category>
      
    </categories>
    
    
    <tags>
      
      <tag>算法</tag>
      
      <tag>选择排序</tag>
      
      <tag>插入排序</tag>
      
      <tag>快速排序</tag>
      
      <tag>归并排序</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>Hello World</title>
    <link href="/hello-world/"/>
    <url>/hello-world/</url>
    
    <content type="html"><![CDATA[<center>Hello, world!</center>]]></content>
    
    
    <categories>
      
      <category>杂项</category>
      
    </categories>
    
    
    <tags>
      
      <tag>hello, world</tag>
      
    </tags>
    
  </entry>
  
  
  
  
</search>
